#include <time.h>
#include <ctype.h>

#include "lib/libpe/error.h"
#include "pex.h"
#include "common.h"
#include "plugins.h"

parse_pe_ctx_t *parse_pe_init()
{
    parse_pe_ctx_t *ctx = NULL;

    ctx = (parse_pe_ctx_t *)calloc(1, sizeof(parse_pe_ctx_t));
        
    return ctx;
}

int parse_pe_load_file(parse_pe_ctx_t *ctx, char *path)
{
    int ret = PEX_E_OK;
    
    ret = pe_load_file(&ctx->pe_ctx, path);
    if(PEX_E_OK != ret)
        goto error;
    
    return ret;

error:
    pe_unload(&ctx->pe_ctx);
    return ret;
}

void parse_pe_unload_file(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return;
    
    pe_unload(&ctx->pe_ctx);
}

bool pex_is_loaded(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return false;
    
    return pe_is_loaded(&ctx->pe_ctx);
}

int pex_parse_pe(parse_pe_ctx_t *ctx)
{
    int ret = PEX_E_OK;
    
    if(ctx == NULL)
        return PEX_E_NULL_PTR;

    ret = pe_parse(&ctx->pe_ctx);
    return ret;
}

bool pex_is_pe(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return false;

    return pe_is_pe(&ctx->pe_ctx);
}

bool pex_is_dll(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return false;

    return pe_is_dll(&ctx->pe_ctx);
}

void parse_pe_free(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return;
    
    pe_unload(&ctx->pe_ctx);
    free(ctx);
}

IMAGE_DOS_HEADER *pex_dos(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return NULL;
    
    return pe_dos(&ctx->pe_ctx);
}

IMAGE_FILE_HEADER *pex_file(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return NULL;
    
    return pe_coff(&ctx->pe_ctx);
}

IMAGE_OPTIONAL_HEADER *pex_optional(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return NULL;
    
    return pe_optional(&ctx->pe_ctx);
}

uint32_t pex_directories_count(parse_pe_ctx_t *ctx) 
{
    if(ctx == NULL)
        return 0;
    
	return pe_directories_count(&ctx->pe_ctx);
}

IMAGE_DATA_DIRECTORY **pex_directories(parse_pe_ctx_t *ctx) 
{
    if(ctx == NULL)
        return NULL;
    
	return pe_directories(&ctx->pe_ctx);
}

IMAGE_DATA_DIRECTORY *pex_directory_by_entry(parse_pe_ctx_t *ctx, ImageDirectoryEntry entry)
{
    if(ctx == NULL)
        return NULL;
    
	return pe_directory_by_entry(&ctx->pe_ctx, entry);
}

uint16_t pex_sections_count(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return 0;
    
	return pe_sections_count(&ctx->pe_ctx);
}

IMAGE_SECTION_HEADER **pex_sections(parse_pe_ctx_t *ctx)
{
    if(ctx == NULL)
        return NULL;
    
	return pe_sections(&ctx->pe_ctx);
}

IMAGE_SECTION_HEADER *pex_section_by_name(parse_pe_ctx_t *ctx, char *section_name)
{
    if(ctx == NULL)
        return NULL;
    
	return pe_section_by_name(&ctx->pe_ctx, section_name);
}

static void print_key_val(const char *key, const char *val)
{
    printf("\t%-40s%s\n", key, val);
}

void print_dos_header(IMAGE_DOS_HEADER *header)
{
    char s[MAX_MSG];
    
    printf("DOS Header\n");

    snprintf(s, MAX_MSG, "%#x (MZ)", header->e_magic);
    print_key_val("Magic number:", s);

    snprintf(s, MAX_MSG, "%d", header->e_cblp);
    print_key_val("Bytes in last page:", s);

    snprintf(s, MAX_MSG, "%d", header->e_cp);
    print_key_val("Pages in file:", s);

    snprintf(s, MAX_MSG, "%d", header->e_crlc);
    print_key_val("Relocations:", s);

    snprintf(s, MAX_MSG, "%d", header->e_cparhdr);
    print_key_val("Size of header in paragraphs:", s);

    snprintf(s, MAX_MSG, "%d", header->e_minalloc);
    print_key_val("Minimum extra paragraphs:", s);

    snprintf(s, MAX_MSG, "%d", header->e_maxalloc);
    print_key_val("Maximum extra paragraphs:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_ss);
    print_key_val("Initial (relative) SS value:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_sp);
    print_key_val("Initial SP value:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_ip);
    print_key_val("Initial IP value:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_cs);
    print_key_val("Initial (relative) CS value:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_lfarlc);
    print_key_val("Address of relocation table:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_ovno);
    print_key_val("Overlay number:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_oemid);
    print_key_val("OEM identifier:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_oeminfo);
    print_key_val("OEM information:", s);

    snprintf(s, MAX_MSG, "%#x", header->e_lfanew);
    print_key_val("PE header offset:", s);

}

void print_file_header(IMAGE_FILE_HEADER *header)
{
    
    const char *machine = pe_machine_type_name(header->Machine);
    if (machine == NULL)
        machine = "Unknown machine type";

    char s[MAX_MSG];
    
    printf("COFF/File header\n");

    snprintf(s, MAX_MSG, "%#x %s", header->Machine, machine);
    print_key_val("Machine", s);

    snprintf(s, MAX_MSG, "%d", header->NumberOfSections);
    print_key_val("Number of sections", s);

    char timestr[40];
    strftime(timestr, sizeof(timestr), "%a, %d %b %Y %H:%M:%S UTC",
        gmtime((time_t *) &header->TimeDateStamp));
    snprintf(s, MAX_MSG, "%d (%s)", header->TimeDateStamp, timestr);
    print_key_val("Date/time stamp", s);

    snprintf(s, MAX_MSG, "%#x", header->PointerToSymbolTable);
    print_key_val("Symbol Table offset", s);

    snprintf(s, MAX_MSG, "%d", header->NumberOfSymbols);
    print_key_val("Number of symbols", s);

    snprintf(s, MAX_MSG, "%#x", header->SizeOfOptionalHeader);
    print_key_val("Size of optional header", s);

    snprintf(s, MAX_MSG, "%#x", header->Characteristics);
    print_key_val("Characteristics", s);
    
    print_key_val("Characteristics names", NULL);
    for (uint16_t i = 0, flag = 0x0001; i < 16; i++, flag <<= 1) 
    {
        if (header->Characteristics & flag)
            print_key_val(NULL, pe_image_characteristic_name(flag));
    }
}

