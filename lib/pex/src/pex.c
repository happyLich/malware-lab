#include <ctype.h>
#include <time.h>
#include <math.h>

#include "lib/libpe/error.h"
#include "lib/libpe/pe.h"

#include "pex.h"
#include "common.h"

#define PE_VALID_SECTION_NAME \
            ".text.bss.data.rsrc.debug.reloc.winzip.tls.UPX.boom.seau"\
            ".code.Shared.gentee.CODE.DATA.BSS.CRT.PAGE.INIT.res.asp.tsu.TEXT."

static double calculate_entropy(const unsigned int counted_bytes[256], const size_t total_length)
{
    static const double log_2 = 1.44269504088896340736;
    double entropy = 0.;

    for(size_t i = 0; i < 256; i++) 
    {
        double temp = (double)counted_bytes[i] / total_length;
        if (temp > 0.)
            entropy += fabs(temp * (log(temp) * log_2));
    }

    return entropy;
}

double calculate_entropy_file(pe_ctx_t *ctx)
{
    unsigned int counted_bytes[256];
    memset(counted_bytes, 0, sizeof(counted_bytes));

    const uint8_t *file_bytes = LIBPE_PTR_ADD(ctx->map_addr, 0);
    const uint64_t filesize = pe_filesize(ctx);
    for(uint64_t ofs = 0; ofs < filesize; ofs++) 
    {
        const uint8_t byte = file_bytes[ofs];
        counted_bytes[byte]++;
    }

    return calculate_entropy(counted_bytes, (size_t)filesize);
}

int8_t cpl_analysis(pe_ctx_t *ctx)
{
    const IMAGE_COFF_HEADER *hdr_coff_ptr = pe_coff(ctx);
    const IMAGE_DOS_HEADER *hdr_dos_ptr = pe_dos(ctx);

    if(hdr_coff_ptr == NULL || hdr_dos_ptr == NULL)
        return -1;

    static const uint16_t characteristics1 =
        ( IMAGE_FILE_EXECUTABLE_IMAGE
        | IMAGE_FILE_LINE_NUMS_STRIPPED
        | IMAGE_FILE_LOCAL_SYMS_STRIPPED
        | IMAGE_FILE_BYTES_REVERSED_LO
        | IMAGE_FILE_32BIT_MACHINE
        | IMAGE_FILE_DLL
        | IMAGE_FILE_BYTES_REVERSED_HI);
    static const uint16_t characteristics2 =
        ( IMAGE_FILE_EXECUTABLE_IMAGE
        | IMAGE_FILE_LINE_NUMS_STRIPPED
        | IMAGE_FILE_LOCAL_SYMS_STRIPPED
        | IMAGE_FILE_BYTES_REVERSED_LO
        | IMAGE_FILE_32BIT_MACHINE
        | IMAGE_FILE_DEBUG_STRIPPED
        | IMAGE_FILE_DLL
        | IMAGE_FILE_BYTES_REVERSED_HI);
    static const uint16_t characteristics3 =
        ( IMAGE_FILE_EXECUTABLE_IMAGE
        | IMAGE_FILE_LINE_NUMS_STRIPPED
        | IMAGE_FILE_32BIT_MACHINE
        | IMAGE_FILE_DEBUG_STRIPPED
        | IMAGE_FILE_DLL);

    if((hdr_coff_ptr->TimeDateStamp == 708992537 ||
            hdr_coff_ptr->TimeDateStamp > 1354555867)
        && (hdr_coff_ptr->Characteristics == characteristics1 || // equals 0xa18e
            hdr_coff_ptr->Characteristics == characteristics2 || // equals 0xa38e
            hdr_coff_ptr->Characteristics == characteristics3) // equals 0x2306
        && hdr_dos_ptr->e_sp == 0xb8)
    {
        return 1;
    }

    return 0;
}

// new anti-disassembly technique with undocumented Intel FPU instructions
bool fpu_trick(pe_ctx_t *ctx)
{
    const char *opcode_ptr = ctx->map_addr;

    for(uint32_t i = 0, times = 0; i < ctx->map_size; i++) 
    {
        if(*opcode_ptr++ == '\xdf')
        {
            if(++times == 4)
                return true;
        }
        else
            times = 0;
    }

    return false;
}

bool normal_imagebase(pe_ctx_t *ctx)
{
    return  (ctx->pe.imagebase == 0x100000000 ||
            ctx->pe.imagebase == 0x1000000 ||
            ctx->pe.imagebase == 0x400000);
}

IMAGE_SECTION_HEADER *pe_check_fake_entrypoint(pe_ctx_t *ctx)
{
    const IMAGE_OPTIONAL_HEADER *optional = pe_optional(ctx);
    if(optional == NULL)
        return NULL;
        
    const uint16_t num_sections = pe_sections_count(ctx);
    if(num_sections == 0)
        return NULL;
    
    uint32_t ep = (optional->_32 ? optional->_32->AddressOfEntryPoint :
        (optional->_64 ? optional->_64->AddressOfEntryPoint : 0));

    IMAGE_SECTION_HEADER *section = pe_rva2section(ctx, ep);
    if(section == NULL)
        return NULL;

    if(section->Characteristics & IMAGE_SCN_CNT_CODE)
        return NULL;

    return section;
}

// check for abnormal dos stub (common in packed files)
bool normal_dos_stub(pe_ctx_t *ctx, uint32_t *stub_offset)
{
    const uint8_t dos_stub[] =
        "\x0e"               // push cs
        "\x1f"               // pop ds
        "\xba\x0e\x00"       // mov dx, 0x0e
        "\xb4\x09"           // mov ah, 0x09
        "\xcd\x21"           // int 0x21
        "\xb8\x01\x4c"       // mov ax, 0x4c01
        "\xcd\x21"           // int 0x21
        "This program cannot be run in DOS mode.\r\r\n$";

    const size_t dos_stub_size = sizeof(dos_stub) - 1; // -1 to ignore ending null

    const IMAGE_DOS_HEADER *dos = pe_dos(ctx);
    if(dos == NULL)
        return true;

    *stub_offset = dos->e_cparhdr << 4;

    // dos stub starts at e_cparhdr shifted by 4
    const char *dos_stub_ptr = LIBPE_PTR_ADD(ctx->map_addr, *stub_offset);
    if(!pe_can_read(ctx, dos_stub_ptr, dos_stub_size)) 
    {
        return true;
    }

    return memcmp(dos_stub, dos_stub_ptr, dos_stub_size) == 0;
}

static uint32_t pe_get_tls_directory(pe_ctx_t *ctx)
{
    if(ctx->pe.num_directories == 0 || ctx->pe.num_directories > MAX_DIRECTORIES)
        return 0;

    const IMAGE_DATA_DIRECTORY *directory = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_TLS);
    if(directory == NULL)
        return 0;

    if(directory->Size == 0)
        return 0;

    return directory->VirtualAddress;
}

/*
 * -1 - fake tls callbacks detected
 *  0 - no tls directory
 * >0 - number of callbacks functions found
*/
int pe_get_tls_callbacks(pe_ctx_t *ctx)
{
    int ret = 0;

    const IMAGE_OPTIONAL_HEADER *optional_hdr = pe_optional(ctx);
    if(optional_hdr == NULL)
        return 0;

    IMAGE_SECTION_HEADER ** const sections = pe_sections(ctx);
    if(sections == NULL)
        return 0;

    const uint64_t tls_addr = pe_get_tls_directory(ctx);
    if(tls_addr == 0)
        return 0;

    const uint16_t num_sections = pe_sections_count(ctx);

    uint64_t ofs = 0;

    // search for tls in all sections
    uint16_t i, j;
    for(i = 0, j = 0; i < num_sections; i++)
    {
        if(tls_addr >= sections[i]->VirtualAddress &&
            tls_addr < (sections[i]->VirtualAddress + sections[i]->SizeOfRawData))
        {
            ofs = tls_addr - sections[i]->VirtualAddress + sections[i]->PointerToRawData;

            switch(optional_hdr->type) 
            {
                default:
                    return 0;
                case MAGIC_PE32:
                {
                    const IMAGE_TLS_DIRECTORY32 *tls_dir = LIBPE_PTR_ADD(ctx->map_addr, ofs);
                    if(!pe_can_read(ctx, tls_dir, sizeof(IMAGE_TLS_DIRECTORY32))) 
                    {
                        return 0;
                    }

                    if (!(tls_dir->AddressOfCallBacks & optional_hdr->_32->ImageBase))
                        break;

                    ofs = pe_rva2ofs(ctx, tls_dir->AddressOfCallBacks - optional_hdr->_32->ImageBase);
                    break;
                }
                case MAGIC_PE64:
                {
                    const IMAGE_TLS_DIRECTORY64 *tls_dir = LIBPE_PTR_ADD(ctx->map_addr, ofs);
                    if(!pe_can_read(ctx, tls_dir, sizeof(IMAGE_TLS_DIRECTORY64))) 
                    {
                        return 0;
                    }

                    if(!(tls_dir->AddressOfCallBacks & optional_hdr->_64->ImageBase))
                        break;

                    ofs = pe_rva2ofs(ctx, tls_dir->AddressOfCallBacks - optional_hdr->_64->ImageBase);
                    break;
                }
            }

            ret = -1; // tls directory and section exists

            uint32_t funcaddr = 0;

            do
            {
                const uint32_t *funcaddr_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
                if(!pe_can_read(ctx, funcaddr_ptr, sizeof(*funcaddr_ptr))) 
                {
                    return 0;
                }

                uint32_t funcaddr = *funcaddr_ptr;
                if(funcaddr)
                {
                    ret = ++j; // function found
                }
            } while(funcaddr);

            return ret;
        }
    }

    return 0;
}

static bool strisprint(const char *string)
{
    if(strstr(PE_VALID_SECTION_NAME, string))
        return true;
    
    return false;
}

void get_strange_sections_num(pe_ctx_t *ctx, uint16_t *num_sections, 
                int *num_zero_len, int *num_sus_name, int *num_self_mdf)
{
    IMAGE_SECTION_HEADER **sections = pe_sections(ctx);
    
    *num_zero_len = 0;
    *num_sus_name = 0;
    *num_self_mdf = 0;
    
    *num_sections = pe_sections_count(ctx);
    if(*num_sections == 0)
        return;

    for(uint16_t i=0; i < *num_sections; i++)
    {
        if(!strisprint((const char *)sections[i]->Name))
        {
            (*num_sus_name)++;
        }

        if(sections[i]->SizeOfRawData == 0)
        {
            (*num_zero_len)++;
        }

        // rwx or writable + executable code
        if(sections[i]->Characteristics & IMAGE_SCN_MEM_WRITE &&
            (sections[i]->Characteristics & IMAGE_SCN_CNT_CODE ||
            sections[i]->Characteristics & IMAGE_SCN_MEM_EXECUTE))
        {
            (*num_self_mdf)++;
        }
    }
}


