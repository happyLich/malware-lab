#include <base/pecker.h>
#include <base/pecker_log.h>
#include <dirent.h>
#include <libsvm/svm.h>

#include "pecker_mcla.h"
#include "pecker_mcla_svm.h"
#include "pecker_mcla_train.h"
#include "pecker_mcla_img.h"
#include "pecker_mcla_util.h"

static uint32_t g_width = 256;
static int g_dist = 1;
static uint8_t g_angel = GLCM_ANGLE_HORIZATION;

static void generate_image_glcm_vector(void *content, uint32_t len, 
        void *ptr, uint32_t input_num);

mcla_t *pecker_mcla_init()
{
    mcla_t *mcla;
    pecker_log_init("pecker_mcla", -1, 1, -1);
    
    mcla = (mcla_t *)calloc(1, sizeof(mcla_t));
    if(NULL == mcla)
        goto error;

    return mcla;

error:
    pecker_mcla_free(mcla);
    return NULL;
}

int pecker_mcla_free(mcla_t *mcla)
{
    int ret = PECKER_MCLA_OK;
    
    if(mcla)
    {
        pecker_svm_free(mcla->svm_m);
    }
    
    PECKER_MCLA_FREE(mcla);

    return ret;
}

int pecker_mcla_load_model(mcla_t *mcla, char *src, uint32_t input_num, uint32_t model_type)
{
    int ret = PECKER_MCLA_OK;
    
    if(mcla == NULL)
        return PECKER_MCLA_NULL_POINTER;

    if(NULL == mcla->svm_m)
    {
        mcla->svm_m = pecker_svm_init();
        if(NULL == mcla->svm_m)
        {
            ret = PECKER_MCLA_SVM_INIT_FAIL;
            goto exit;
        }
    }
    
    mcla->input_num = input_num;
    mcla->model_type = model_type;
    if(model_type & BIN_IMAGE)
    {
        mcla->generate_feat_vector = generate_image_glcm_vector;
    }

    ret = pecker_svm_load_model(mcla->svm_m, src);

exit:
    return ret;
}

int pecker_mcla_predict_file(mcla_t *mcla, char *src)
{
    int ret = PECKER_MCLA_OK;
    struct svm_node *svm_nd = NULL;
    uint32_t input_num, len;
    FILE *fp = NULL;
    uint8_t *buf;
    struct stat  sstat;
    
    if(mcla == NULL)
        return PECKER_MCLA_NULL_POINTER;
        
    if(mcla->model_type & BIN_IMAGE)
    {
        fp = fopen(src, "r");
        if(NULL == fp)
        {        
            pecker_log(PECKER_LOG_ERR, "predict file open  %s failed\n", src);
            return PECKER_MCLA_OPEN_FILE_FAIL;
        }
        
        stat(src, &sstat);
        len = sstat.st_size;
        buf = (uint8_t *)malloc(len);
        if(len != fread(buf, 1, len, fp))
        {
            fclose(fp);
            pecker_log(PECKER_LOG_ERR, "predict file read %s failed\n", src);
            return PECKER_MCLA_READ_FILE_FAIL;
        }
        
        fclose(fp);
        input_num = mcla->input_num;
        svm_nd = (struct svm_node *)calloc(input_num + 1, sizeof(struct svm_node));
        mcla->generate_feat_vector(buf, len, svm_nd, input_num);
    }
    
    mcla->svm_m->svm_nd = svm_nd;
    ret = pecker_svm_predict(mcla->svm_m);
    if(ret == PECKER_MCLA_OK)
    {
        mcla->report = mcla->svm_m->report;
    }

    PECKER_MCLA_FREE(svm_nd);
    mcla->svm_m->svm_nd = NULL;
    
    return ret;
}

int pecker_mcla_creat_img_train_data(char *src, char *dst)
{
    int ret = PECKER_MCLA_OK;
    uint8_t buf[1025]= "";
    img_train_data_para_t train_para;
    int lable;
    FILE *fp = NULL;
    uint32_t width = 256;
    int dist = 1;
    uint32_t angel = GLCM_ANGLE_HORIZATION;
    uint8_t *pos = NULL;
    uint32_t len = 0;
    
    if(src == NULL || dst == NULL)
        return PECKER_MCLA_NULL_POINTER;

    fp = fopen(src, "r");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;
    init_img_train_data_para(&train_para, width, dist, angel);
    while(fgets(buf, 1024, fp))
    {
        len = strlen(buf);
                
        for( ; len > 0; len--)
        {
            if(buf[len - 1] == '\r' || buf[len - 1] == '\n')
                buf[len - 1] = '\0';
            else
                break;
        }
        
        if(len == 0)
            continue;
        
        if(strncasecmp(buf, "[para]", 6) == 0)
        {
            pos = buf + 6;
            sscanf(pos, "%u %d %u", &width, &dist, &angel);
            pecker_log(PECKER_LOG_INFO, "[para]%d %d %d\n", width, dist, angel);
            init_img_train_data_para(&train_para, width, dist, angel);
        }
        
        if(len == 0 || !isdigit(buf[0]))
        {
            continue;
        }
        else
        {
            pos = strchr(buf, ',');
            if(pos == NULL)
                continue;
            pos++;
            lable = atoi(buf);
            add_img_train_data(&train_para, pos, lable);
        }
    }
    fclose(fp);
    
    creat_img_train_data(&train_para, dst);
    free_img_train_data_para(&train_para);
        
exit:
    return ret;
}

static int convert_bin2img(char *src, char *dst, uint32_t height, uint32_t width)
{
    int ret = PECKER_MCLA_OK;
    FILE *fp = NULL;
    uint32_t len;
    uint8_t *buf;
    struct stat sstat;
    
    fp = fopen(src, "r");
    if(NULL == fp)
    {
        return PECKER_MCLA_OPEN_FILE_FAIL;
    }
    
    stat(src, &sstat);
    len = sstat.st_size;
    buf = (uint8_t *)malloc(len);
    if(len == fread(buf, 1, len, fp))
    {
        
        ret = binary_to_img(buf, len, height, width, dst);
    }
    else
    {
        pecker_log(PECKER_LOG_ERR, "%s to %s, read file %s fail!\n", src, dst, src);
        ret = PECKER_MCLA_READ_FILE_FAIL;
    }
    
    free(buf);
    fclose(fp);
        
    return ret;
}

int pecker_mcla_bin2img(char *src, char *dst, uint32_t height, uint32_t width)
{
    int ret = PECKER_MCLA_OK;
    char src_path[1024];
    char dst_path[1024];
    struct dirent *filename;
    char *file_name;
    DIR *dir;
    struct stat sstat;
    
    lstat(src, &sstat);
    if(!S_ISDIR(sstat.st_mode))
    {
        if ((file_name = strrchr(src, '/')) != NULL)
            file_name++;
        else
            file_name = src;

        sprintf(dst_path, "%s/%s.png", dst, file_name);
        ret = convert_bin2img(src, dst_path, height, width);     
    }
    else
    {
        dir = opendir(src);
        if(dir == NULL)
        {
            pecker_log(PECKER_LOG_ERR, "open dir %s error!\n", src);
           return PECKER_MCLA_OPEN_DIR_FAIL;
        }
        
        while((filename = readdir(dir)) != NULL)
        {
            if(!strcmp(filename->d_name, ".")||!strcmp(filename->d_name, ".."))
                continue;
        
            sprintf(src_path, "%s/%s", src, filename->d_name);
        
            lstat(src_path, &sstat);
        
            if(!S_ISDIR(sstat.st_mode))
            {
                if ((file_name = strrchr(src_path, '/')) != NULL)
                    file_name++;
                else
                    file_name = src_path;
                
                sprintf(dst_path, "%s/%s.png", dst, file_name);
                ret = convert_bin2img(src_path, dst_path, height, width);     
            }
            else
            {
                continue;
            }
        }
        closedir(dir);
    }
        
    return ret;
}

static void generate_image_glcm_vector(void *data, uint32_t len, 
            void *ptr, uint32_t input_num)
{
    glcm_val_t glcm_v;
    struct svm_node *svm_nd = (struct svm_node *)ptr;
    uint8_t *content = (uint8_t *)data;
    
    calc_all_glcm(content, len, g_width, g_angel, g_dist, &glcm_v);
    
    svm_nd[0].index = 1;
    svm_nd[0].value = glcm_v._contrast;

    svm_nd[1].index = 2;
    svm_nd[1].value = glcm_v._homogeneity;

    svm_nd[2].index = 3;
    svm_nd[3].value = glcm_v._correlation;
    
    svm_nd[3].index = 4;
    svm_nd[3].value = glcm_v._dissimilarity;
    
    svm_nd[4].index = 5;
    svm_nd[4].value = glcm_v._asm;
    
    svm_nd[5].index = 6;
    svm_nd[5].value = glcm_v._entropy;
    
    svm_nd[6].index = 7;
    svm_nd[6].value = glcm_v._mean;
    
    svm_nd[7].index = 8;
    svm_nd[7].value = glcm_v._variance;
    
    svm_nd[input_num].index = -1;
}

