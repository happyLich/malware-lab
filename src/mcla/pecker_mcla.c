#include <base/pecker.h>
#include <base/pecker_log.h>
#include <dirent.h>
#include <libsvm/svm.h>

#include "pecker_mcla.h"
#include "pecker_mcla_svm.h"
#include "pecker_mcla_train.h"
#include "pecker_mcla_img.h"
#include "pecker_mcla_pe.h"
#include "pecker_mcla_util.h"

static uint32_t g_width = 256;
static int g_dist = 1;
static uint8_t g_angel = GLCM_ANGLE_HORIZATION;

typedef struct
{
    glcm_val_t glcm_val;
    pe_val_t pe_val;
} all_feat_val_t;

static void generate_all_feat_vector(void *, size_t, struct svm_node *, uint32_t);

mcla_t *pecker_mcla_init()
{
    mcla_t *mcla;
    pecker_log_init("pecker_mcla", -1, 1, -1);
    
    mcla = (mcla_t *)calloc(1, sizeof(mcla_t));
    if(NULL == mcla)
        goto error;

    return mcla;

error:
    pecker_mcla_free(mcla);
    return NULL;
}

int pecker_mcla_free(mcla_t *mcla)
{
    int ret = PECKER_MCLA_OK;
    
    if(mcla)
    {
        pecker_svm_free(mcla->svm_m);
    }
    
    PECKER_MCLA_FREE(mcla);

    return ret;
}

int pecker_mcla_load_model(mcla_t *mcla, char *model_src, 
            char *normal_para_path, uint32_t input_num, uint32_t model_type)
{
    int ret = PECKER_MCLA_OK;
    
    if(mcla == NULL)
        return PECKER_MCLA_NULL_POINTER;

    if(NULL == mcla->svm_m)
    {
        mcla->svm_m = pecker_svm_init();
        if(NULL == mcla->svm_m)
        {
            ret = PECKER_MCLA_SVM_INIT_FAIL;
            goto exit;
        }
    }
    
    mcla->input_num = input_num;
    mcla->model_type = model_type;

    ret = pecker_svm_load_model(mcla->svm_m, model_src, normal_para_path, input_num, generate_all_feat_vector);

exit:
    return ret;
}

//DOING:
static void generate_all_feat_vector(void *data, size_t len, struct svm_node *svm_nd, uint32_t input_num)
{
    all_feat_val_t *feat_val = (all_feat_val_t *)data;

    //glcm_val
    svm_nd[0].index = 1;
    svm_nd[0].value = feat_val->glcm_val._contrast;

    svm_nd[1].index = 2;
    svm_nd[1].value = feat_val->glcm_val._homogeneity;

    svm_nd[2].index = 3;
    svm_nd[3].value = feat_val->glcm_val._correlation;
    
    svm_nd[3].index = 4;
    svm_nd[3].value = feat_val->glcm_val._dissimilarity;
    
    svm_nd[4].index = 5;
    svm_nd[4].value = feat_val->glcm_val._asm;
    
    svm_nd[5].index = 6;
    svm_nd[5].value = feat_val->glcm_val._entropy;
    
    svm_nd[6].index = 7;
    svm_nd[6].value = feat_val->glcm_val._mean;
    
    svm_nd[7].index = 8;
    svm_nd[7].value = feat_val->glcm_val._variance;

    //pe_val    
    svm_nd[GLCM_FEAT_VAL_NUM].index = GLCM_FEAT_VAL_NUM + 1;
    svm_nd[GLCM_FEAT_VAL_NUM].value = feat_val->pe_val.is_dll;

    svm_nd[GLCM_FEAT_VAL_NUM + 1].index = GLCM_FEAT_VAL_NUM + 2;
    svm_nd[GLCM_FEAT_VAL_NUM + 1].value = feat_val->pe_val.cpl;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 2].index = GLCM_FEAT_VAL_NUM + 3;
    svm_nd[GLCM_FEAT_VAL_NUM + 2].value = feat_val->pe_val.entropy;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 3].index = GLCM_FEAT_VAL_NUM + 4;
    svm_nd[GLCM_FEAT_VAL_NUM + 3].value = feat_val->pe_val.fpu_trick;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 4].index = GLCM_FEAT_VAL_NUM + 5;
    svm_nd[GLCM_FEAT_VAL_NUM + 4].value = feat_val->pe_val.normal_imagebase;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 5].index = GLCM_FEAT_VAL_NUM + 6;
    svm_nd[GLCM_FEAT_VAL_NUM + 5].value = feat_val->pe_val.fake_entry;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 6].index = GLCM_FEAT_VAL_NUM + 7;
    svm_nd[GLCM_FEAT_VAL_NUM + 6].value = feat_val->pe_val.dos_stub;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 7].index = GLCM_FEAT_VAL_NUM + 8;
    svm_nd[GLCM_FEAT_VAL_NUM + 7].value = feat_val->pe_val.tls_dir;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 8].index = GLCM_FEAT_VAL_NUM + 9;
    svm_nd[GLCM_FEAT_VAL_NUM + 8].value = feat_val->pe_val.num_sec;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 9].index = GLCM_FEAT_VAL_NUM + 10;
    svm_nd[GLCM_FEAT_VAL_NUM + 9].value = feat_val->pe_val.zero_len;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 10].index = GLCM_FEAT_VAL_NUM + 11;
    svm_nd[GLCM_FEAT_VAL_NUM + 10].value = feat_val->pe_val.sus_name;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 11].index = GLCM_FEAT_VAL_NUM + 12;
    svm_nd[GLCM_FEAT_VAL_NUM + 11].value = feat_val->pe_val.self_mdf;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 12].index = GLCM_FEAT_VAL_NUM + 13;
    svm_nd[GLCM_FEAT_VAL_NUM + 12].value = feat_val->pe_val.size_init;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 13].index = GLCM_FEAT_VAL_NUM + 14;
    svm_nd[GLCM_FEAT_VAL_NUM + 13].value = feat_val->pe_val.dll_cha;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 14].index = GLCM_FEAT_VAL_NUM + 15;
    svm_nd[GLCM_FEAT_VAL_NUM + 14].value = feat_val->pe_val.im_ver;
    
    svm_nd[GLCM_FEAT_VAL_NUM + 15].index = GLCM_FEAT_VAL_NUM + 16;
    svm_nd[GLCM_FEAT_VAL_NUM + 15].value = feat_val->pe_val.check_sum;
    
    svm_nd[input_num].index = -1;
    
    return;
}

int pecker_mcla_analysis_pe_file(mcla_t *mcla, char *src, int *report, int cmd)
{
    int ret = PECKER_MCLA_OK;
    pe_ctx_t *ctx = NULL;
    
    all_feat_val_t all_feat;
    bzero(&all_feat, sizeof(all_feat_val_t));
    
    *report = PE_MARWARE_OK;
    
    ctx = analysis_pe(src, report, &all_feat.pe_val, NULL, 0);
    if(*report != PE_MARWARE_OK || cmd == MACHINE_LEARN_CLOSE)
    {
        goto exit;
    }
    
    ret = calc_all_glcm((uint8_t *)ctx->map_addr, ctx->map_size, g_width, g_angel, g_dist, &all_feat.glcm_val);
    if(ret != PECKER_MCLA_OK)
    {
        goto exit;
    }

    ret = pecker_svm_predict(mcla->svm_m, &all_feat, 0);
    if(ret != PECKER_MCLA_OK)
    {
        goto exit;
    }

    if(mcla->svm_m->report > 0.5)
    {
        *report = PE_MARWARE_ML;
    }

exit:
    pe_ctx_free(ctx);
    return ret;
}

int pecker_mcla_creat_img_train_data(char *src, char *dst)
{
    int ret = PECKER_MCLA_OK;
    uint8_t buf[1025]= "";
    img_train_data_para_t train_para;
    int lable;
    FILE *fp = NULL;
    uint32_t width = 256;
    int dist = 1;
    uint32_t angel = GLCM_ANGLE_HORIZATION;
    uint8_t *pos = NULL;
    uint32_t len = 0;
    
    if(src == NULL || dst == NULL)
        return PECKER_MCLA_NULL_POINTER;

    fp = fopen(src, "r");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;
    
    init_img_train_data_para(&train_para, g_width, g_dist, g_angel);
    
    while(fgets(buf, 1024, fp))
    {
        len = strlen(buf);
                
        for( ; len > 0; len--)
        {
            if(buf[len - 1] == '\r' || buf[len - 1] == '\n')
                buf[len - 1] = '\0';
            else
                break;
        }
        
        if(len == 0)
            continue;
        
        if(strncasecmp(buf, "[para]", 6) == 0)
        {
            pos = buf + 6;
            sscanf(pos, "%u %d %u", &width, &dist, &angel);
            pecker_log(PECKER_LOG_INFO, "[para]%d %d %d\n", width, dist, angel);
            init_img_train_data_para(&train_para, width, dist, angel);
        }
        
        if(len == 0 || !isdigit(buf[0]))
        {
            continue;
        }
        else
        {
            pos = strchr(buf, ',');
            if(pos == NULL)
                continue;
            pos++;
            lable = atoi(buf);
            add_img_train_data(&train_para, pos, lable);
        }
    }
    fclose(fp);
    
    creat_img_train_data(&train_para, dst);
    free_img_train_data_para(&train_para);
        
exit:
    return ret;
}

static int convert_bin2img(char *src, char *dst, uint32_t height, uint32_t width)
{
    int ret = PECKER_MCLA_OK;
    FILE *fp = NULL;
    uint32_t len;
    uint8_t *buf;
    struct stat sstat;
    
    fp = fopen(src, "r");
    if(NULL == fp)
    {
        return PECKER_MCLA_OPEN_FILE_FAIL;
    }
    
    stat(src, &sstat);
    len = sstat.st_size;
    buf = (uint8_t *)malloc(len);
    if(len == fread(buf, 1, len, fp))
    {
        
        ret = binary_to_img(buf, len, height, width, dst);
    }
    else
    {
        pecker_log(PECKER_LOG_ERR, "%s to %s, read file %s fail!\n", src, dst, src);
        ret = PECKER_MCLA_READ_FILE_FAIL;
    }
    
    free(buf);
    fclose(fp);
        
    return ret;
}

int pecker_mcla_bin2img(char *src, char *dst, uint32_t height, uint32_t width)
{
    int ret = PECKER_MCLA_OK;
    char src_path[1024];
    char dst_path[1024];
    struct dirent *filename;
    char *file_name;
    DIR *dir;
    struct stat sstat;
    
    lstat(src, &sstat);
    if(!S_ISDIR(sstat.st_mode))
    {
        if ((file_name = strrchr(src, '/')) != NULL)
            file_name++;
        else
            file_name = src;

        sprintf(dst_path, "%s/%s.png", dst, file_name);
        ret = convert_bin2img(src, dst_path, height, width);
    }
    else
    {
        dir = opendir(src);
        if(dir == NULL)
        {
            pecker_log(PECKER_LOG_ERR, "open dir %s error!\n", src);
           return PECKER_MCLA_OPEN_DIR_FAIL;
        }
        
        while((filename = readdir(dir)) != NULL)
        {
            if(!strcmp(filename->d_name, ".")||!strcmp(filename->d_name, ".."))
                continue;
        
            sprintf(src_path, "%s/%s", src, filename->d_name);
        
            lstat(src_path, &sstat);
        
            if(!S_ISDIR(sstat.st_mode))
            {
                if ((file_name = strrchr(src_path, '/')) != NULL)
                    file_name++;
                else
                    file_name = src_path;
                
                sprintf(dst_path, "%s/%s.png", dst, file_name);
                ret = convert_bin2img(src_path, dst_path, height, width);     
            }
            else
            {
                continue;
            }
        }
        closedir(dir);
    }
        
    return ret;
}

int pecker_mcla_creat_pe_train_data(char *src, char *dst)
{
    int ret = PECKER_MCLA_OK;
    uint8_t buf[1025]= "";    
    int lable;
    FILE *fp = NULL;
    uint8_t *pos = NULL;
    uint32_t len = 0;
    
    pe_train_data_para_t train_para;
    
    if(src == NULL || dst == NULL)
        return PECKER_MCLA_NULL_POINTER;

    fp = fopen(src, "r");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;
    
    init_pe_train_data_para(&train_para);
    
    while(fgets(buf, 1024, fp))
    {
        len = strlen(buf);
        
        for( ; len > 0; len--)
        {
            if(buf[len - 1] == '\r' || buf[len - 1] == '\n')
                buf[len - 1] = '\0';
            else
                break;
        }
        
        if(len == 0)
            continue;
        
        if(strncasecmp(buf, "[para]", 6) == 0)
        {
            pecker_log(PECKER_LOG_INFO, "[para]\n");
            init_pe_train_data_para(&train_para);
        }
        
        if(len == 0 || !isdigit(buf[0]))
        {
            continue;
        }
        else
        {
            pos = strchr(buf, ',');
            if(pos == NULL)
                continue;
            pos++;
            lable = atoi(buf);
            add_pe_train_data(&train_para, pos, lable);
        }
    }
    fclose(fp);
    
    creat_pe_train_data(&train_para, dst);
    free_pe_train_data_para(&train_para);
        
exit:
    return ret;
}

int pecker_mcla_creat_all_train_data(char *src, char *img_dst, char *pe_dst)
{
    int ret = PECKER_MCLA_OK;
    uint8_t buf[1025]= "";
    int lable;
    FILE *fp = NULL;
    uint8_t *pos = NULL;
    uint32_t len = 0;
    
    pe_ctx_t ctx;
    
    pe_train_data_para_t pe_para;
    img_train_data_para_t img_para;
    
    if(src == NULL || img_dst == NULL || pe_dst == NULL)
        return PECKER_MCLA_NULL_POINTER;

    fp = fopen(src, "r");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;
    
    init_pe_train_data_para(&pe_para);
    init_img_train_data_para(&img_para, g_width, g_dist, g_angel);
        
    while(fgets(buf, 1024, fp))
    {
        len = strlen(buf);
        
        for( ; len > 0; len--)
        {
            if(buf[len - 1] == '\r' || buf[len - 1] == '\n')
                buf[len - 1] = '\0';
            else
                break;
        }
        
        if(len == 0)
            continue;
        
        if(strncasecmp(buf, "[para]", 6) == 0)
        {
            pecker_log(PECKER_LOG_INFO, "[para]\n");
        }
        
        if(len == 0 || !isdigit(buf[0]))
        {
            continue;
        }
        else
        {
            pos = strchr(buf, ',');
            if(pos == NULL)
                continue;
            pos++;
            lable = atoi(buf);
            
            ret = pe_load_file(&ctx, pos);
            if(ret != LIBPE_E_OK) 
            {
                pe_unload(&ctx);
                continue;
            }
            
            ret = pe_parse(&ctx);
            if(ret != LIBPE_E_OK) 
            {
                pe_unload(&ctx);
                continue;
            }
            
            if(!pe_is_pe(&ctx))
            {
                pe_unload(&ctx);
                continue;
            }
            
            pe_unload(&ctx);
            
            add_pe_train_data(&pe_para, pos, lable);
            add_img_train_data(&img_para, pos, lable);
        }
    }
    fclose(fp);
    
    creat_pe_train_data(&pe_para, pe_dst);
    free_pe_train_data_para(&pe_para);
    
    creat_img_train_data(&img_para, img_dst);
    free_img_train_data_para(&img_para);

exit:
    return ret;
}

