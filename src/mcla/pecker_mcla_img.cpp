#ifdef __cplusplus
extern "C"
{
#endif

#include <base/pecker.h>
#include <base/pecker_log.h>

#ifdef __cplusplus
}
#endif

#include <opencv2/core/core.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>

#include "pecker_mcla_img.h"
#include "pecker_mcla_util.h"

using namespace cv;
using namespace std;

int read_img(char *filename)
{
    Mat img = imread(filename, CV_LOAD_IMAGE_UNCHANGED);
    if(img.empty())
    {
        printf("read %s fail\n", filename);
        return 0;
    }

    printf("read %s ok\n", filename);
    return 1;
}

int binary_to_img(uint8_t *data, uint32_t size, uint32_t height, uint32_t width, char *dst)
{
    Mat image, save_img;    
    uint32_t i = 0, j = 0, k = 0;
    uint32_t src_height = size / width;

    if(0 == src_height)
        src_height = 1;

    image = Mat(src_height, width, CV_8U);

    for(i = 0; i < src_height; i++)
    {
        for(j = 0; j < width; j++)
        {
            k = i * width + j;
            if(k < size)
            {
                image.at<uint8_t>(i, j) = data[k];
            }
            else
            {
                image.at<uint8_t>(i, j) = 0;
            }
        }
    }
        
    resize(image, save_img, Size(width, height), 0, 0, INTER_CUBIC); 
    
    vector<int>compression_params;  
    compression_params.push_back(CV_IMWRITE_PNG_COMPRESSION);
    //cvtColor(image, save_img, CV_BGR2GRAY);

    if(imwrite(dst, save_img, compression_params) == true)
    {
        return PECKER_MCLA_OK;
    }
    else
    {
        return PECKER_MCLA_SAVE_IMG_FAIL;
    }
    
}

double *make_glcm(uint8_t *data, uint32_t size, uint32_t width, uint8_t angel, int dist)
{
    uint32_t height = size / width;
    uint8_t *image = NULL;
    double *glcm = NULL;
    
    if(0 == height)
        height = 1;
    image = (uint8_t *)malloc(height * width * sizeof(uint8_t));

    //init image martrix
    uint32_t x = 0, y = 0, z = 0;
    for(x = 0; x < height; x++)
    {
        for(y = 0 ; y < width; y++)
        {
            z = x * width + y;
            if(z < size)
            {
                image[z] = data[z];
            }
            else
            {
                image[z] = 0;
            }
        }
    }
    
    int i, j, k, l;
    //init glcm martrix
    glcm = (double *)malloc(GLCM_GRAY_LEVEL * GLCM_GRAY_LEVEL * sizeof(double));
    for(i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            glcm[i * GLCM_GRAY_LEVEL + j] = 0;
        }
    }

    //generate glcm martrix
    uint32_t count = 0;
    if(angel == GLCM_ANGLE_HORIZATION)
    {
        for (i = 0; i < height; i++)
        {  
            for (j = 0; j < width; j++)
            {  
                l = image[i * width + j];
                if(j + dist >= 0 && j + dist < width)
                {
                    k = image[i * width + j + dist];
                    glcm[l * GLCM_GRAY_LEVEL + k]++;
                    count++;
                }
                if(j - dist >= 0 && j - dist < width)  
                {  
                    k = image[i * width + j - dist];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++;                    
                    count++;
                }  
            }  
        } 
    }
    else if(angel == GLCM_ANGLE_VERTICAL)
    {
        for (i = 0;i < height;i++)  
        {  
            for (j = 0;j < width;j++)  
            {  
                l = image[i * width + j];  
                if(i + dist >= 0 && i + dist < height)   
                {  
                    k = image[(i + dist) * width + j];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++;  
                    count++;
                }  
                if(i - dist >= 0 && i - dist < height)   
                {  
                    k = image[(i - dist) * width + j];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++;  
                    count++;
                }  
            }  
        } 
    }
    else if(angel == GLCM_ANGLE_DIGONAL)
    {
        for (i = 0;i < height;i++)  
        {  
            for (j = 0;j < width;j++)  
            {  
                l = image[i * width + j];  
        
                if(j + dist >= 0 && j + dist < width && i + dist >= 0 && i + dist < height)  
                {  
                    k = image[(i + dist) * width + j + dist];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++; 
                    count++;
                }  
                if(j - dist >= 0 && j - dist < width && i - dist >= 0 && i - dist < height)  
                {  
                    k = image[(i - dist) * width + j - dist];
                    glcm[l * GLCM_GRAY_LEVEL + k]++;  
                    count++;
                }  
            }  
        } 
    }
    
    for(i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            glcm[i * GLCM_GRAY_LEVEL + j] /= count;
        }
    }
    
    PECKER_MCLA_FREE(image);
    return glcm;
}

void free_glcm(double *glcm)
{
    PECKER_MCLA_FREE(glcm);
}

int calc_all_glcm(uint8_t *data, uint32_t size, uint32_t width, uint8_t angel, int dist, glcm_val_t *glcm_val)
{
    double glcm[GLCM_GRAY_LEVEL * GLCM_GRAY_LEVEL];
    uint32_t height = size / width;
    uint8_t *image = NULL;
    uint32_t x, y, z;
    int i, j, k, l;
    
    if(glcm_val == NULL)
        return PECKER_MCLA_NULL_POINTER;
    
    if(0 == height)
        height = 1;
    image = (uint8_t *)malloc(height * width * sizeof(uint8_t));
    
    //init image martrix
    for(x = 0, z = 0; x < height; x++)
    {
        for(y = 0 ; y < width; y++)
        {
            if(z < size)
            {
                image[x * width + y] = data[z];
            }
            else
            {
                image[x * width + y] = 0;
            }
            z++;
        }
    }
    
    //init glcm martrix
    for(i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            glcm[i * GLCM_GRAY_LEVEL + j] = 0;
        }
    }

    //generate glcm martrix
    uint32_t count = 0;
    if(angel == GLCM_ANGLE_HORIZATION)
    {
        for (i = 0; i < height; i++)
        {  
            for (j = 0; j < width; j++)
            {  
                l = image[i * width + j];
                if(j + dist >= 0 && j + dist < width)
                {
                    k = image[i * width + j + dist];
                    glcm[l * GLCM_GRAY_LEVEL + k]++;
                    count++;
                }
                if(j - dist >= 0 && j - dist < width)  
                {  
                    k = image[i * width + j - dist];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++;                    
                    count++;
                }  
            }  
        } 
    }
    else if(angel == GLCM_ANGLE_VERTICAL)
    {
        for (i = 0;i < height;i++)  
        {  
            for (j = 0;j < width;j++)  
            {  
                l = image[i * width + j];  
                if(i + dist >= 0 && i + dist < height)   
                {  
                    k = image[(i + dist) * width + j];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++;  
                    count++;
                }  
                if(i - dist >= 0 && i - dist < height)   
                {  
                    k = image[(i - dist) * width + j];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++;  
                    count++;
                }  
            }  
        } 
    }
    else if(angel == GLCM_ANGLE_DIGONAL)
    {
        for (i = 0;i < height;i++)  
        {  
            for (j = 0;j < width;j++)  
            {  
                l = image[i * width + j];  
        
                if(j + dist >= 0 && j + dist < width && i + dist >= 0 && i + dist < height)  
                {  
                    k = image[(i + dist) * width + j + dist];  
                    glcm[l * GLCM_GRAY_LEVEL + k]++; 
                    count++;
                }  
                if(j - dist >= 0 && j - dist < width && i - dist >= 0 && i - dist < height)  
                {  
                    k = image[(i - dist) * width + j - dist];
                    glcm[l * GLCM_GRAY_LEVEL + k]++;  
                    count++;
                }  
            }  
        } 
    }

    //normalization glcm martrix
    for(i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            glcm[i * GLCM_GRAY_LEVEL + j] /= count;
        }
    }
    PECKER_MCLA_FREE(image);
    
    //calc glcm feature value
    bzero(glcm_val, sizeof(glcm_val_t));
    for (i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for (j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            k = i * GLCM_GRAY_LEVEL + j;
            glcm_val->_mean += (glcm[k] * i);
            glcm_val->_contrast += (glcm[k] * ((i - j) * (i - j)));
            glcm_val->_dissimilarity += (glcm[k] * abs(i - j));
            glcm_val->_homogeneity += ((glcm[k]) / (1 + (i - j)*(i - j)));
            glcm_val->_asm += (glcm[k] * glcm[k]);
            if(0 != glcm[k])
                glcm_val->_entropy -= ((glcm[k]) * log(glcm[k]));
        }
    }

    for (i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for (j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            k = i * GLCM_GRAY_LEVEL + j;
            glcm_val->_variance += (glcm[k] * ((i - glcm_val->_mean) * (i - glcm_val->_mean)));
        }
    }

    for (i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for (j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            k = i * GLCM_GRAY_LEVEL + j;
            if(0 != glcm_val->_variance)
                glcm_val->_correlation += (((i - glcm_val->_mean) * (j - glcm_val->_mean)) * (glcm[k] * glcm[k]) / glcm_val->_variance);
        }
    }

    return PECKER_MCLA_OK;
}

double calc_contrast(double *glcm)
{
    double sum = 0;
    for (int i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for (int j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            sum += glcm[i * GLCM_GRAY_LEVEL + j] * ((i - j)*(i - j));
        }
    }
    return sum;
}

double calc_dissimilarity(double *glcm)
{
    double sum = 0;
    for(int i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(int j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            sum += glcm[i * GLCM_GRAY_LEVEL + j] * abs(i - j);
        }
    }
    return sum;
}

double calc_homogeneity(double *glcm)
{
    double sum = 0;
    for(int i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(int j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            sum += (glcm[i * GLCM_GRAY_LEVEL + j]) / (1 + (i - j)*(i - j));
        }
    }
    return sum;
}

double calc_asm(double *glcm)
{
    double sum = 0;
    for(int i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(int j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            sum += (glcm[i * GLCM_GRAY_LEVEL + j] * glcm[i * GLCM_GRAY_LEVEL + j]);
        }
    }
    return sum;
}

double calc_entropy(double *glcm)
{
    double sum = 0;
    for(int i = 0; i < GLCM_GRAY_LEVEL; i++)
    {
        for(int j = 0; j < GLCM_GRAY_LEVEL; j++)
        {
            if(glcm[i * GLCM_GRAY_LEVEL + j] != 0)
            {
                sum -= ((glcm[i * GLCM_GRAY_LEVEL + j]) * log(glcm[i * GLCM_GRAY_LEVEL + j]));
            }
        }
    }
    return sum;
}

//creat image feature train data
int init_img_train_data_para(img_train_data_para_t *para, uint32_t width, int dist, uint8_t angel)
{
    int ret = PECKER_MCLA_OK;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;

    para->img_list = NULL;
    para->img_num = 0;
    para->img_max = 0;
    para->width = width;
    para->dist = dist;
    para->angel = angel;

    return ret;
}

int add_img_train_data(img_train_data_para_t *para, char *src, int lable)
{
    int ret = PECKER_MCLA_OK;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
            
    if(para->img_num >= para->img_max)
    {
        para->img_list = (img_node_t *)realloc(para->img_list, 
                (para->img_max + IMAGE_NODE_REALLOC_SIZE) * sizeof(img_node_t));
        para->img_max += IMAGE_NODE_REALLOC_SIZE;
    }
    
    para->img_list[para->img_num].path = strdup(src);
    para->img_list[para->img_num].lable = lable;
    
    pecker_log(PECKER_LOG_INFO, "add %s, lable: %d\n", para->img_list[para->img_num].path, para->img_list[para->img_num].lable);
    para->img_num++;
        
    return ret;
}

int creat_img_train_data(img_train_data_para_t *para, char *dst)
{
    int ret = PECKER_MCLA_OK;
    glcm_val_t glcm_v;
    FILE *fpw, *fpr;
    uint32_t len;
    uint8_t *buf;
    struct stat sstat;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
    
    fpw = fopen(dst, "w");
    if(NULL == fpw)
        return PECKER_MCLA_OPEN_FILE_FAIL;

    pecker_log(PECKER_LOG_INFO, "creat_img_train_data %s\n", dst);

    uint32_t i;
    img_node_t *img_node;
    fprintf(fpw, "lable,contrast,homogeneity,correlation,dissimilarity,asm,entropy,mean,variance\n");
    for(i = 0; i < para->img_num; i++)
    {
        img_node = para->img_list + i;
        
        fpr = fopen(img_node->path, "r");
        if(NULL == fpr)
            continue;
        
        stat(img_node->path, &sstat);
        len = sstat.st_size;
        buf = (uint8_t *)malloc(len);
        if(len == fread(buf, 1, len, fpr))
        {
            calc_all_glcm(buf, len, para->width, para->angel, para->dist, &glcm_v);
            free(buf);
            fclose(fpr);
        }
        else
        {
            fclose(fpr);
            free(buf);
            continue;
        }
                        
        fprintf(fpw, "%d,", img_node->lable);
        fprintf(fpw, "%f,", glcm_v._contrast);
        fprintf(fpw, "%f,", glcm_v._homogeneity);
        fprintf(fpw, "%f,", glcm_v._correlation);
        fprintf(fpw, "%f,", glcm_v._dissimilarity);
        fprintf(fpw, "%f,", glcm_v._asm);
        fprintf(fpw, "%f,", glcm_v._entropy);
        fprintf(fpw, "%f,", glcm_v._mean);
        fprintf(fpw, "%f", glcm_v._variance);
        fprintf(fpw, "\n");
    }

    fclose(fpw);
    return ret;
}

int free_img_train_data_para(img_train_data_para_t *para)
{
    if(para)
    {
        int i = 0;
        for(i = 0; i < para->img_num; i++)
        {
            PECKER_MCLA_FREE(para->img_list[i].path);
        }
        PECKER_MCLA_FREE(para->img_list);
    }
    return PECKER_MCLA_OK;
}


