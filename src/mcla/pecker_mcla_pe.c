#include <base/pecker.h>
#include <base/pecker_log.h>
#include <pex.h>

#include "pecker_mcla_pe.h"
#include "pecker_mcla_util.h"

//creat PE structure feature train data
 int init_pe_train_data_para(pe_train_data_para_t *para)
{
    int ret = PECKER_MCLA_OK;

    para->pe_list = NULL;
    para->pe_max = 0;
    para->pe_num = 0;

    return ret;
}

int add_pe_train_data(pe_train_data_para_t *para, char *src, int lable)
{
    int ret = PECKER_MCLA_OK;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
        
    if(para->pe_num >= para->pe_max)
    {
        para->pe_list = (pe_node_t *)realloc(para->pe_list, 
                (para->pe_max + PE_NODE_REALLOC_SIZE) * sizeof(pe_node_t));        
        para->pe_max += PE_NODE_REALLOC_SIZE;
    }

    para->pe_list[para->pe_num].path = strdup(src);
    para->pe_list[para->pe_num].lable = lable;
    pecker_log(PECKER_LOG_DEBUG, "add %s, lable: %d\n", para->pe_list[para->pe_num].path, para->pe_list[para->pe_num].lable);
    
    para->pe_num++;
    
    return ret;
}

//TODO:
int creat_pe_train_data(pe_train_data_para_t *para, char *dst)
{
    int ret = PECKER_MCLA_OK;
    pe_ctx_t ctx;
    IMAGE_OPTIONAL_HEADER *opt_header;
    pe_node_t *pe_node;
    FILE *fp;
    
    uint32_t stub_offset;
    uint16_t num_sections; 
    int num_zero_len; 
    int num_sus_name; 
    int num_self_mdf;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
    
    fp = fopen(dst, "w");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;
    
    fprintf(fp, "lable,");
    fprintf(fp, "is_dll,cpl,file_entropy,fpu_trick,normal_imagebase,fake_entry,");
    fprintf(fp, "dos_stub,tls_dir,num_sec,zero_len,sus_name,self_mdf,");
    fprintf(fp, "size_init,dll_cha,im_ver,check_sum");
    fprintf(fp, "\n");
    
    uint32_t i;
    for(i = 0; i < para->pe_num; i++)
    {
        pe_node = para->pe_list + i;

        ret = pe_load_file(&ctx, pe_node->path);
        if(ret != LIBPE_E_OK) 
        {
            pecker_log(PECKER_LOG_ERR, "load %s fail, ret: %d\n", pe_node->path, ret);
            pe_unload(&ctx);
            continue;
        }

        ret = pe_parse(&ctx);
        if(ret != LIBPE_E_OK) 
        {
            pecker_log(PECKER_LOG_ERR, "parse %s fail, ret: %d\n", pe_node->path, ret);
            pe_unload(&ctx);
            continue;
        }

        if(!pe_is_pe(&ctx))
        {
            pecker_log(PECKER_LOG_ERR, "%s is not pe\n", pe_node->path);
            pe_unload(&ctx);
            continue;
        }

        //lable
        fprintf(fp, "%d,", pe_node->lable);        

        //is_dll, cpl  
        if(pe_is_dll(&ctx)) 
        {
            if(cpl_analysis(&ctx))
            {
                fprintf(fp, "1,1,");
            }
            else
            {
                fprintf(fp, "1,0,");
            }
        }
        else
        {
            fprintf(fp, "0,0,");
        }

        //entropy
        fprintf(fp, "%f,", calculate_entropy_file(&ctx));

        //fpu anti-disassembly
        if(fpu_trick(&ctx))
        {
            fprintf(fp, "1,");
        }
        else
        {
            fprintf(fp, "0,");
        }

        //normal_imagebase
        if(normal_imagebase(&ctx))
        {
            fprintf(fp, "1,");
        }
        else
        {
            fprintf(fp, "0,");
        }

        //fake_entrypoint
        if(pe_check_fake_entrypoint(&ctx))
        {
            fprintf(fp, "1,");
        }
        else
        {
            fprintf(fp, "0,");
        }

        //normal_dos_stub        
        if(normal_dos_stub(&ctx, &stub_offset))
        {
            fprintf(fp, "1,");
        }
        else
        {
            fprintf(fp, "0,");
        }

        //TLS_directory
        fprintf(fp, "%d,", pe_get_tls_callbacks(&ctx));

        //num_sec, zero_len,  sus_name, self_mdf
        get_strange_sections_num(&ctx, &num_sections, &num_zero_len, &num_sus_name, &num_self_mdf);
        fprintf(fp, "%d,%d,%d,%d,", num_sections, num_zero_len, num_sus_name, num_self_mdf);

        //Optional header, SizeOfInitializedData, DllCharacteristics, MajorImageVersion, CheckSum
        opt_header = pe_optional(&ctx);
        if(opt_header)
        {
            switch (opt_header->type)
            {
                case MAGIC_PE32:
                {
                    fprintf(fp, "%d,", opt_header->_32->SizeOfInitializedData);
                    fprintf(fp, "%d,", opt_header->_32->DllCharacteristics);
                    fprintf(fp, "%d,", opt_header->_32->MajorImageVersion);
                    fprintf(fp, "%d", opt_header->_32->CheckSum);
                    break;
                }
                case MAGIC_PE64:
                {
                    fprintf(fp, "%d,", opt_header->_64->SizeOfInitializedData);
                    fprintf(fp, "%d,", opt_header->_64->DllCharacteristics);
                    fprintf(fp, "%d,", opt_header->_64->MajorImageVersion);
                    fprintf(fp, "%d", opt_header->_64->CheckSum);
                    break;
                }
            }
        }
        else
        {
            fprintf(fp, "0,0,0,0");
        }
        
        fprintf(fp, "\n");

        pe_unload(&ctx);
    }

    fclose(fp);
    return ret;
}

int free_pe_train_data_para(pe_train_data_para_t *para)
{    
    if(para)
    {
        int i = 0;
        for(i = 0; i < para->pe_num; i++)
        {
            PECKER_MCLA_FREE(para->pe_list[i].path);
        }
        
        PECKER_MCLA_FREE(para->pe_list);
    }
    
    return PECKER_MCLA_OK;
}

pe_ctx_t *analysis_pe(char *src, int *report, pe_val_t *pe_val, char *msg, int cmd)
{
    int ret = PECKER_MCLA_OK;
    pe_ctx_t *ctx = NULL;
    IMAGE_OPTIONAL_HEADER *opt_header;
    
    uint32_t stub_offset;
    uint16_t num_sections;
    int num_zero_len;
    int num_sus_name;
    int num_self_mdf;
    
    if(src == NULL || report == NULL || report == NULL)
    {
        *report = PE_MARWARE_ERR;
        return NULL;
    }

    ctx = pe_ctx_init();
    ret = pe_load_file(ctx, src);
    if(ret != LIBPE_E_OK)
    {
        pecker_log(PECKER_LOG_ERR, "load %s fail, ret: %d\n", src, ret);
        
        *report = PE_MARWARE_LOAD_ERR;
        goto exit;
    }

    ret = pe_parse(ctx);
    if(ret != LIBPE_E_OK) 
    {
        pecker_log(PECKER_LOG_ERR, "parse %s fail, ret: %d\n", src, ret);
        
        *report = PE_MARWARE_PARSE_ERR;
        goto exit;
    }

    if(!pe_is_pe(ctx))
    {
        pecker_log(PECKER_LOG_ERR, "%s is not pe\n", src);
        
        *report = PE_MARWARE_IS_NOT_PE;
        ret = PE_MARWARE_IS_NOT_PE;
        goto exit;
    }

    //is_dll, cpl  
    if(pe_is_dll(ctx))
    {
        pe_val->is_dll = 1;
        if(cpl_analysis(ctx))
        {            
            *report = PE_MARWARE_CPL;
            pe_val->cpl = 1;
            goto exit;
        }
        else
        {
            pe_val->cpl = 0;
        }
    }
    else
    {
        pe_val->is_dll = 0;
        pe_val->cpl = 0;
    }
    
    //fake_entrypoint
    if(pe_check_fake_entrypoint(ctx))
    {
        *report = PE_MARWARE_FAKE_ENTRY;
        pe_val->fake_entry = 1;
        goto exit;
    }
    else
    {
        pe_val->fake_entry = 0;
    }

    //normal_dos_stub        
    if(!normal_dos_stub(ctx, &stub_offset))
    {
        *report = PE_MARWARE_DOS_STUB;
        pe_val->dos_stub = 0;
        goto exit;
    }
    else
    {
        pe_val->dos_stub = 1;
    }

    //num_sec, zero_len,  sus_name, self_mdf
    get_strange_sections_num(ctx, &num_sections, &num_zero_len, &num_sus_name, &num_self_mdf);
    pe_val->num_sec = num_sections;
    pe_val->zero_len = num_zero_len;
    pe_val->sus_name = num_sus_name;
    pe_val->self_mdf = num_self_mdf;
    
#if 0   
    if(num_sus_name > 0)
    {
        *report = PE_MARWARE_SUS_NAME;
        goto exit;
    }
#endif

    if(num_self_mdf > 0)
    {
        *report = PE_MARWARE_SELF_MODIFY;
        goto exit;
    }

    //Optional header, SizeOfInitializedData, DllCharacteristics, MajorImageVersion, CheckSum
    opt_header = pe_optional(ctx);
    if(opt_header)
    {
        switch (opt_header->type)
        {
            case MAGIC_PE32:
            {
                if(opt_header->_32->SizeOfInitializedData == 0)
                {
                    *report = PE_MARWARE_OPTIONAL;
                    goto exit;
                }
                if(opt_header->_32->DllCharacteristics == 0 && opt_header->_32->MajorImageVersion == 0 
                    && opt_header->_32->CheckSum == 0)
                {
                    *report = PE_MARWARE_OPTIONAL;
                    goto exit;
                }
                pe_val->size_init = opt_header->_32->SizeOfInitializedData;
                pe_val->dll_cha = opt_header->_32->DllCharacteristics;
                pe_val->im_ver = opt_header->_32->MajorImageVersion;
                pe_val->check_sum = opt_header->_32->CheckSum;
                break;
            }
            case MAGIC_PE64:
            {
                if(opt_header->_64->SizeOfInitializedData == 0)
                {
                    *report = PE_MARWARE_OPTIONAL;
                    goto exit;
                }
                if(opt_header->_64->DllCharacteristics == 0 && opt_header->_64->MajorImageVersion == 0 
                    && opt_header->_64->CheckSum == 0)
                {
                    *report = PE_MARWARE_OPTIONAL;
                    goto exit;
                }
                pe_val->size_init = opt_header->_64->SizeOfInitializedData;
                pe_val->dll_cha = opt_header->_64->DllCharacteristics;
                pe_val->im_ver = opt_header->_64->MajorImageVersion;
                pe_val->check_sum = opt_header->_64->CheckSum;
                break;
            }
        }
    }

    //entropy
    pe_val->entropy = calculate_entropy_file(ctx);

    //fpu anti-disassembly
    if(fpu_trick(ctx))
    {
        pe_val->fpu_trick = 1;
    }
    else
    {
        pe_val->fpu_trick = 0;
    }

    //normal_imagebase
    if(normal_imagebase(ctx))
    {
        pe_val->normal_imagebase = 1;
    }
    else
    {
        pe_val->normal_imagebase = 0;
    }
    
    //TLS_directory
    pe_val->tls_dir = pe_get_tls_callbacks(ctx);
    
    *report = PE_MARWARE_OK;
    
exit:
    return ctx;
}

