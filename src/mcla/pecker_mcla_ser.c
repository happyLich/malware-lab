#include <base/pecker.h>
#include "pecker_mcla.h"
#include <dirent.h>
#include <getopt.h>
#include <libconfig.h>

#define DEAD_CODE 0
#define MCLA_SERVER_HELP  \
    "Usage: %s [OPTION...] [STRING...]\n\n" \
    "    -h, --help                      display this help and exit\n"\
    "\n"\
    "    -s, --start                     start mcla server\n"\
    "    -c, --conf                      set the config path\n"\
    "\n"

#define MCLA_SER_CONF_PATH              "/polyhawk/mcla/mcla.cfg"
#define MCLA_SER_DEF_IP                 "127.0.0.1"
#define MCLA_SER_DEF_PORT                  8345
#define MCLA_SER_DEF_MAX_WAIT_CONN          10
#define MCLA_SER_MAX_WAIT_CONN             300
#define MCLA_SER_RECE_TIMEOUT               15
#define MCLA_SER_BUF_SZIE                  2048

static char *progname;     /* used throughout */
static int opt;
static struct option longopts[] = {
    {"help", 0, NULL, 'h'},
    {"start", 0, NULL, 's'},
    {"conf", 1, NULL, 'c'},
    {0,0,0,0}
};

typedef struct
{
    char ip[64];
    int port;
    int max_wait_conn;
    int rece_timeout;

    mcla_t *mcla;
    
    //daemon
    int daemon;

    //config
    config_t cfg;
    
} mcla_ser_config_t;

typedef struct 
{
    int  socket;  
} mcla_ser_thread_para_t;

mcla_ser_config_t g_conf;
pthread_mutex_t mcla_ser_mutex;
char *ser_conf_path = MCLA_SER_CONF_PATH;

static void mcla_server_help(void);
static int mcla_ser_init_conf(mcla_ser_config_t *conf);
static void mcla_daemonise();
static void *mcla_ser_connection_handler(void *parama);
static uint8_t *mcla_ser_recv_data(int s, int timeout, size_t *data_len);
static int mcla_ser_send_data(int s, uint8_t *buf, size_t *len);
static int mcla_ser_free(mcla_ser_config_t *conf);

int main(int argc, char **argv)
{
    int ret = 0;
    int helpinfo = 1;
    
    if ((progname = strrchr(argv[0], '/')) != NULL)
        progname++;
    else
        progname = argv[0];

    while((opt = getopt_long(argc, argv, "hsc:", longopts, NULL)) != -1)
    {
        switch(opt)
        {
            case 's':
                helpinfo = 0;
                break;
            case 'c':
                ser_conf_path = strdup(optarg);
                break;
            case 'h':
                helpinfo++;
                break;
            case '?':
                helpinfo++;
                break;
            default:
                helpinfo++;
                break;
        }
    }
    
    if(helpinfo)
    {
        mcla_server_help();
    }

    mcla_ser_init_conf(&g_conf);
    
    //start tcp server
    int socket_desc , new_socket , c;
    struct sockaddr_in server, client;
    
    //ign signal 
    signal(SIGPIPE, SIG_IGN);

    //create socket
    socket_desc = socket(AF_INET, SOCK_STREAM , 0);
    if(socket_desc == -1)
    {
        printf("SOCKET: Could not create socket.");
        mcla_ser_free(&g_conf);
        exit(2);
    }
    printf("SOCEKT: create socket ok.");

    //Prepare the sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr(g_conf.ip);
    server.sin_port = htons(g_conf.port);

     //Bind
    if(bind(socket_desc,(struct sockaddr *)&server , sizeof(server)) < 0)
    {
        printf("SOCKET: bind failed.");
        mcla_ser_free(&g_conf);
        exit(3);
    }
    printf("SOCKET: bind ip:%s port:%d ok.", g_conf.ip, g_conf.port);

    //Listen
    listen(socket_desc, g_conf.max_wait_conn);

    //daemon
    if(g_conf.daemon)
    {
        mcla_daemonise();
    }
    printf("DAEMON: ok.");

    //Accept incoming connection 
    printf("CONN: Waiting for incoming connections...");

    uint64_t num = 0;
    c = sizeof(struct sockaddr_in);
    while(1)
    {
        //new connect
        new_socket = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c);

        if(new_socket < 0)
        {
            printf("CONN: accept error, exit");
            break;
        }

        printf("CONN: NO. %lu conect", ++num);

        //create param
        mcla_ser_thread_para_t *param = (mcla_ser_thread_para_t *)malloc(sizeof(mcla_ser_thread_para_t));
        if(param == NULL)
        {
            printf("THREAD: malloc param fail.");
            close(new_socket);
            continue;
        }
        param->socket = new_socket;

        //create thread
        pthread_t sniffer_thread;
        
        if(pthread_create(&sniffer_thread, NULL, mcla_ser_connection_handler, (void*)param) < 0)
        {
            printf("THREAD:could not create thread.");
            free(param);
            close(new_socket);
            continue;
        }
         
        printf("THREAD: new thread Handler assigned.");
    }
     
    mcla_ser_free(&g_conf);
    close(socket_desc);

    return ret;
}

static void mcla_server_help(void)
{
    (void)fprintf(stderr, MCLA_SERVER_HELP, progname);
    exit(1);
}

static int mcla_ser_init_conf(mcla_ser_config_t *conf)
{
    //check 
    if (conf == NULL)
        return -1;

    config_t *cfg = &(conf->cfg);;
    const char *str;

    //init
    config_init(cfg);
    bzero(conf, sizeof(mcla_ser_config_t));
     
    // read the file
    if(!config_read_file(cfg, ser_conf_path))
    {
        sprintf(conf->ip, "%s", MCLA_SER_DEF_IP);
        conf->port =  MCLA_SER_DEF_PORT;
        conf->max_wait_conn = MCLA_SER_DEF_MAX_WAIT_CONN;
        conf->rece_timeout = MCLA_SER_RECE_TIMEOUT;

        return 0;
    } 
    
    //ip
    if(!config_lookup_string(cfg, "mcla.ip", &str))
        sprintf(conf->ip, "%s", MCLA_SER_DEF_IP);
    else
        sprintf(conf->ip, "%s", str);

    //port
    if(!config_lookup_int(cfg, "mcla.port", &(conf->port)))
        conf->port = MCLA_SER_DEF_PORT;
    else
    {
        if(conf->port <= 0 || conf->port >= 65535)
            conf->port = MCLA_SER_DEF_PORT;
    }

    //max wait connect num
    if(!config_lookup_int(cfg, "mcla.max_wait_conn", &(conf->max_wait_conn)))
        conf->max_wait_conn = MCLA_SER_DEF_MAX_WAIT_CONN;
    else
    {
        if(conf->max_wait_conn <= 0 || conf->max_wait_conn > MCLA_SER_MAX_WAIT_CONN)
            conf->max_wait_conn = MCLA_SER_DEF_MAX_WAIT_CONN;
    }
    
    //time out
    if(!config_lookup_int(cfg, "mcla.timeout_ser", &(conf->rece_timeout)))
        conf->rece_timeout = MCLA_SER_RECE_TIMEOUT;
    else
    {
        if(conf->rece_timeout <= 0  || conf->rece_timeout > 60)
            conf->rece_timeout = MCLA_SER_RECE_TIMEOUT;
    }
    
    //daemon
    if(!config_lookup_int(cfg, "mcla.daemon", &(conf->daemon)))
        conf->daemon = 1;

    return 0;
}

static void mcla_daemonise() 
{
    // Fork, allowing the parent process to terminate.
    pid_t pid = fork();
    if(pid == -1) 
    {
        printf("DAEMON: failed to fork while daemonising (errno=%d)", errno);
        exit(1);
    } 
    else if(pid != 0) 
    {
        exit(0);
    }

    // Start a new session for the daemon.
    if(setsid()==-1) 
    {
        printf("DAEMON: failed to become a session leader while daemonising (errno=%d)", errno);
        exit(1);
    }

    // Fork again, allowing the parent process to terminate.
    signal(SIGHUP, SIG_IGN);
    pid = fork();
    if(pid == -1)
    {
        printf("DAEMON:failed to fork while daemonising (errno=%d)", errno);
        exit(1);
    } 
    else if(pid != 0) 
    {
        exit(1);
    }

    // Set the current working directory to the root directory.
    if(chdir("./") == -1)
    {
        printf("DAEMON:failed to change working directory while daemonising (errno=%d)", errno);
        exit(1);
    }

    // Set the user file creation mask to zero.
    umask(0);

    // Close then reopen standard file descriptors.
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    if(open("/dev/null", O_RDONLY) == -1) 
    {
        printf("DAEMON:failed to reopen stdin while daemonising (errno=%d)", errno);
        exit(1);
    }
    if(open("/dev/null", O_WRONLY) == -1) 
    {
        printf("DAEMON:failed to reopen stdout while daemonising (errno=%d)", errno);
        exit(1);
    }
    if(open("/dev/null", O_RDWR) == -1) 
    {
        printf("DAEMON:failed to reopen stderr while daemonising (errno=%d)", errno);
        exit(1);
    }
}

/*
 * This will handle connection for each client
 * */
static void *mcla_ser_connection_handler(void *parama)
{
    //Get the socket descriptor
    int ret = 0;
    mcla_ser_thread_para_t *param = (mcla_ser_thread_para_t *)parama;
    int sock = param->socket;
    uint8_t *data = NULL;
    size_t data_len = 0;
    int cmd;
    uint8_t *str = NULL;
    size_t str_len = 0;
    uint8_t *msg = NULL;
    size_t msg_len = 0;

    //receive data
    data = mcla_ser_recv_data(sock, g_conf.rece_timeout, &data_len);
    if(data == NULL)
    {
        goto exit;
    }
    
    //start to find similar
    cmd = *((int *)data + 8);
    str = (uint8_t *)(data + 8 + 4);
    str_len = data_len - 8 - 4 - 1;
    
    msg = (uint8_t *)malloc(msg_len);
    if(msg == NULL)
    {
        goto exit;
    }
    memset(msg, 0, msg_len);
    memcpy(msg, &msg_len, sizeof(msg_len));

    //msg  for send
exit_send:
    //start to send
    if(mcla_ser_send_data(sock, msg, &data_len) == 0)
    {
        printf("SEND: send result ok.\n");
    }
    else
    {
       printf("SEND: send result fail.");	
    }

    //Free the socket pointer
exit:
    if(data)
        free(data);
    if(msg)
        free(msg);

    free(param);
    close(sock);
    return NULL;
}

/**
 *@return: recv msg prt, null is fail
 */
static uint8_t *mcla_ser_recv_data(int s, int timeout, size_t *data_len)
{
    size_t size_recv, total_size = 0;
    struct timeval begin , now;
    double timediff;
    uint8_t chunk[MCLA_SER_BUF_SZIE + 1];
    int first_tag = 0;
    uint8_t *data = NULL;
    size_t *tmp = NULL;
    size_t tmp_len = 0;

    *data_len = 0;
     
    //make socket non blocking
    fcntl(s, F_SETFL, O_NONBLOCK);
    //beginning time
    gettimeofday(&begin , NULL);
    
    while(1)
    {
        gettimeofday(&now , NULL);
         
        //time elapsed in seconds
        timediff = (now.tv_sec - begin.tv_sec) + 1e-6 * (now.tv_usec - begin.tv_usec);
        
        //if you got some data, then break after timeout
        if(timediff > timeout)
        {
            printf("RECV:Receive timeout");
            break;
        }
            
        memset(chunk, 0, MCLA_SER_BUF_SZIE + 1);  //clear the variable
        if((size_recv =  recv(s, chunk, MCLA_SER_BUF_SZIE, 0)) < 0)
        {
            //if nothing was received then we want to wait a little before trying again, 0.1 seconds
            usleep(100000);
        }
        else
        {
            //get message len
            if(first_tag == 0 && size_recv > 8)
            {
                tmp = (size_t *)chunk;
                *data_len = *tmp;
                first_tag = 1;
            }

            if(data == NULL)
            {
                data = (uint8_t *)malloc(size_recv + 1);
                if(data == NULL)
                    break;
                tmp_len = 0;
            }
            else
            {
                if(total_size + size_recv > tmp_len)
                {
                    data = realloc(data, total_size + size_recv + 1);
                    if(data == NULL)
                        break;
                    tmp_len = total_size + size_recv;
                }
            }

            memcpy(data + total_size, chunk, size_recv);
            total_size += size_recv;
            data[total_size] = '\0';

            if(total_size >= *data_len)
            {
                printf("RECV: receive ok[%lu]", *data_len);
                break;
            }
        }
    }

    //last check
    if(*data_len > 0 && *data_len == total_size && data != NULL)
        return data;
    else
    {
        printf("RECV: recv fail.");
        if(data != NULL)
            free(data);
        return NULL;
    }
}

/**
 *@return: 0: ok -1: fail
 */
static int mcla_ser_send_data(int s, uint8_t *buf, size_t *len)
{
    size_t total = 0; 
    size_t bytesleft = *len; 
    size_t n;

    while(total < *len)
    {
        n = send(s, buf + total, bytesleft, 0);
        if(n == -1) 
        { 
            break; 
        }
        total += n;
        bytesleft -= n;
    }
    
    *len = total;
    return (n == -1) ? -1:0;
}

static int mcla_ser_free(mcla_ser_config_t *conf)
{
    return 0;
}

