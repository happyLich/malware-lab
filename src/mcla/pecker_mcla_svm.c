#include <base/pecker.h>
#include <base/pecker_log.h>
#include <libsvm/svm.h>

#include "pecker_mcla_svm.h"
#include "pecker_mcla_util.h"

svm_model_s *pecker_svm_init()
{
    svm_model_s *svm_m = NULL;
    svm_m = (svm_model_s *)calloc(1, sizeof(svm_model_s));
    if(NULL == svm_m)
        goto error;
        
    return svm_m;

error:
    pecker_svm_free(svm_m);
    return NULL;
}

int pecker_svm_free(svm_model_s *svm_m)
{
    if(svm_m)
    {
        svm_free_and_destroy_model(&svm_m->svm);
    }
    PECKER_MCLA_FREE(svm_m);
    return PECKER_MCLA_OK;
}

int pecker_svm_load_model(svm_model_s *svm_m, char *path, 
            void (*generate_feat_vector)(void *, size_t, struct svm_node *, uint32_t))
{
    int ret = PECKER_MCLA_OK;

    if(NULL == svm_m || generate_feat_vector == NULL)
        return PECKER_MCLA_NULL_POINTER;

    if(svm_m->svm)
    {
        svm_free_and_destroy_model(&svm_m->svm);
        svm_m->svm = NULL;
    }

    svm_m->svm = svm_load_model(path);
    if(svm_m->svm == NULL)
        return PECKER_MCLA_SVM_LOAD_MODEL_FAIL;

    svm_m->generate_feat_vector = generate_feat_vector;
        
    return ret;
}

int pecker_svm_predict(svm_model_s *svm_m, uint32_t input_num, void *data, size_t len)
{
    int ret = PECKER_MCLA_OK;
    
    struct svm_node *svm_nd = NULL;

    if(NULL == svm_m || NULL == svm_m->svm || svm_m->generate_feat_vector)
        return PECKER_MCLA_NULL_POINTER;
    
    svm_nd = (struct svm_node *)calloc(1, (input_num + 1) * sizeof(struct svm_node));

    svm_m->generate_feat_vector(data, len, svm_nd, input_num);
    
    svm_m->report = svm_predict(svm_m->svm, svm_nd);
    
    PECKER_MCLA_FREE(svm_nd);
    return ret;
}

