#include <base/pecker.h>
#include <base/pecker_log.h>
#include <libsvm/svm.h>

#include "pecker_mcla_svm.h"
#include "pecker_mcla_util.h"

svm_model_s *pecker_svm_init()
{
    svm_model_s *svm_m = NULL;
    svm_m = (svm_model_s *)calloc(1, sizeof(svm_model_s));
    if(NULL == svm_m)
        goto error;
        
    return svm_m;

error:
    pecker_svm_free(svm_m);
    return NULL;
}

static void pecker_svm_free_model(svm_model_s *svm_m)
{
    if(svm_m)
    {
        svm_free_and_destroy_model(&svm_m->svm);
        PECKER_MCLA_FREE(svm_m->mean);
        PECKER_MCLA_FREE(svm_m->max);
        PECKER_MCLA_FREE(svm_m->min);
        PECKER_MCLA_FREE(svm_m->max_min);
        bzero(svm_m, sizeof(svm_model_s));
    }
}

int pecker_svm_free(svm_model_s *svm_m)
{
    pecker_svm_free_model(svm_m);
    PECKER_MCLA_FREE(svm_m);
    return PECKER_MCLA_OK;
}

static int svm_load_normalize_para(svm_model_s *svm_m, char *path)
{
    int ret = PECKER_MCLA_OK;
    uint32_t input_num;
    FILE *fp = NULL;
    uint8_t buf[1025];
    uint8_t *pos;

    if(NULL == svm_m || path == NULL || svm_m->input_num == 0)
        return PECKER_MCLA_NULL_POINTER;
    
    fp = fopen(path, "r");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;
    
    input_num = svm_m->input_num;
    svm_m->mean = (struct svm_node *)calloc(1, (input_num + 1) * sizeof(struct svm_node));
    svm_m->max = (struct svm_node *)calloc(1, (input_num + 1) * sizeof(struct svm_node));
    svm_m->min = (struct svm_node *)calloc(1, (input_num + 1) * sizeof(struct svm_node));
    svm_m->max_min = (struct svm_node *)calloc(1, (input_num + 1) * sizeof(struct svm_node));

    uint32_t i = 0;
    while(fgets(buf, 1024, fp) && i < input_num)
    {        
        if(buf[0] == '#' || buf[0] == '\r' || buf[0] == '\n' || buf[0] == ' ')
            continue;

        pos = strchr(buf, ',');
        if(pos == NULL)
            continue;
        pos++;

        sscanf(pos, "%lf,%lf,%lf,%lf", &(svm_m->mean[i].value), 
                &(svm_m->max[i].value), &(svm_m->min[i].value), &(svm_m->max_min[i].value));
        i++;
    }
    
    fclose(fp);
    return ret;
}

int pecker_svm_load_model(svm_model_s *svm_m, char *path, char *normal_para_path, uint32_t input_num, 
            void (*generate_feat_vector)(void *, size_t, struct svm_node *, uint32_t))
{
    int ret = PECKER_MCLA_OK;

    if(NULL == svm_m || generate_feat_vector == NULL)
        return PECKER_MCLA_NULL_POINTER;

    pecker_svm_free_model(svm_m);

    svm_m->svm = svm_load_model(path);
    if(svm_m->svm == NULL)
        return PECKER_MCLA_SVM_LOAD_MODEL_FAIL;

    svm_m->generate_feat_vector = generate_feat_vector;
    svm_m->input_num = input_num;

    if(normal_para_path)
    {
        svm_m->normalized = 1;
        ret = svm_load_normalize_para(svm_m, normal_para_path);
        if(ret != PECKER_MCLA_OK)
        {
            pecker_svm_free_model(svm_m);
        }
    }
        
    return ret;
}

static void normalize_feat_vector(svm_model_s *svm_m, struct svm_node *svm_nd)
{
    uint32_t input_num = 0, i = 0;
    input_num = svm_m->input_num;
    for(i = 0; i < input_num; i++)
    {
        if(svm_nd[i].value >= svm_m->max[i].value)
        {
            svm_nd[i].value = svm_m->max[i].value;
        }
        else if(svm_nd[i].value <= svm_m->min[i].value)
        {
            svm_nd[i].value = svm_m->min[i].value;
        }
        
        svm_nd[i].value = (svm_nd[i].value - svm_m->mean[i].value) / svm_m->max_min[i].value;                
    }
}

int pecker_svm_predict(svm_model_s *svm_m, void *data, size_t len)
{
    int ret = PECKER_MCLA_OK;
    uint32_t input_num;
    
    struct svm_node *svm_nd = NULL;

    if(NULL == svm_m || NULL == svm_m->svm || svm_m->generate_feat_vector)
        return PECKER_MCLA_NULL_POINTER;
    
    input_num = svm_m->input_num;
    svm_nd = (struct svm_node *)calloc(1, (input_num + 1) * sizeof(struct svm_node));

    svm_m->generate_feat_vector(data, len, svm_nd, input_num);
    if(svm_m->normalized)
    {
        normalize_feat_vector(svm_m, svm_nd);
    }
    
    svm_m->report = svm_predict(svm_m->svm, svm_nd);
    
    PECKER_MCLA_FREE(svm_nd);
    return ret;
}

