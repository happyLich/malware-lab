#include <base/pecker.h>
#include "pecker_mcla.h"
#include "pecker_mcla_img.h"
#include <dirent.h>
#include <getopt.h>

#define DEAD_CODE 0
#define MCLA_TEST_HELP  \
    "Usage: %s [OPTION...] [STRING...]\n\n" \
    "    -h, --help                      display this help and exit\n\n"\
    "    -r, --read-img                  test function of read image\n"\
    "    -w, --write-img                 test function of write image\n"\
    "    -g, --glcm                      test function of calc glcm value\n"\
    "    -s, --scan-pe                   scan PE file and check malware\n\n"\

static char *progname;     /* used throughout */
static mcla_t *g_mcla = NULL;
static int opt;
static struct option longopts[] = {
    {"help", 0, NULL, 'h'},
    {"read-img", 1, NULL, 'r'},
    {"write-img", 1, NULL, 'w'},
    {"glcm", 1, NULL, 'g'},
    {"scan-pe", 1, NULL, 's'},
    {0,0,0,0}
};

void mcla_test_help(void);
void glcm_function(char *argv);
void read_img_function(char *argv);
void write_img_function(char *argv);
void analysis_pe_function(char *argv);

int main(int argc, char **argv)
{
    int ret = 0;
    int helpinfo = 1;
    
    g_mcla = pecker_mcla_init();

    if ((progname = strrchr(argv[0], '/')) != NULL)
        progname++;
    else
        progname = argv[0];

    while((opt = getopt_long(argc, argv, "hg:r:w:s:", longopts, NULL)) != -1)
    {
        switch(opt)
        {
            case 'r':
                helpinfo = 0;
                read_img_function(optarg);
                break;
            case 'w':
                helpinfo = 0;
                write_img_function(optarg);
                break;
            case 'g':
                helpinfo = 0;
                glcm_function(optarg);
                break;
            case 's':
                helpinfo = 0;
                analysis_pe_function(optarg);
                break;
            case 'h':
                helpinfo++;
                break;
            case '?':
                helpinfo++;
                break;
            default:
                helpinfo++;
                break;
        }
    }
    
    if(helpinfo)
        mcla_test_help();
    
    pecker_mcla_free(g_mcla);
    
    return ret;
}

void mcla_test_help(void)
{
    (void)fprintf(stderr, MCLA_TEST_HELP, progname);
    exit(1);
}

void glcm_function(char *argv)
{
    FILE *fp = NULL;
    uint32_t len;
    uint8_t *buf;
    glcm_val_t glcm_val;
    struct stat  sstat;
    
    fp = fopen(argv, "r");
    if(NULL == fp)
    {
        printf("open  %s failed\n", argv);
        return;
    }
    
    stat(argv, &sstat);
    len = sstat.st_size;
    buf = (uint8_t *)malloc(len);
    if(len == fread(buf, 1, len, fp))
    {
        printf("make_glcm len:%d\n", len);
        calc_all_glcm(buf, len, 256, GLCM_ANGLE_HORIZATION, 1, &glcm_val);
        printf("_mean: %f\n", glcm_val._mean);
        printf("_variance: %f\n", glcm_val._variance);
        printf("_asm: %f\n", glcm_val._asm);
        printf("_contrast: %f\n", glcm_val._contrast);
        printf("_correlation: %f\n", glcm_val._correlation);
        printf("_dissimilarity: %f\n", glcm_val._dissimilarity);
        printf("_entropy: %f\n", glcm_val._entropy);
        printf("_homogeneity: %f\n", glcm_val._homogeneity);
    }
    free(buf);
    fclose(fp);
}

void read_img_function(char *argv)
{
    read_img(argv);
}

void write_img_function(char *argv)
{
    FILE *fp = NULL;
    uint32_t len;
    uint8_t *buf;
    struct stat sstat;
    char dst[1024];
    
    fp = fopen(argv, "r");
    if(NULL == fp)
    {
        printf("open  %s failed\n", argv);
        return;
    }
    
    stat(argv, &sstat);
    len = sstat.st_size;
    buf = (uint8_t *)malloc(len);
    if(len == fread(buf, 1, len, fp))
    {
        sprintf(dst, "%s.png", argv);
        if(0 == binary_to_img(buf, len, 512, 512, dst))
        {
            printf("%s is saved!!\n", dst);
        }
        else
        {
            printf("save %s failed!!\n", dst);
        }
    }
    
    free(buf);
    fclose(fp);
}

void analysis_pe_function(char *argv)
{
    int report;

    struct dirent *filename;
    char src_path[1024];
    DIR *dir;
    struct stat sstat;

    int total_num = 0;
    int good_num = 0;
    int bad_num = 0;
    
    lstat(argv, &sstat);
    if(!S_ISDIR(sstat.st_mode))
    {
        pecker_mcla_analysis_pe_file(g_mcla, argv, &report, 0);
        printf("%s: %d\n", argv, report);
    }
    else
    {
        dir = opendir(argv);
        if(dir == NULL)
        {
            printf("dir %s is null!\n", argv);
           return;
        }
        
        while((filename = readdir(dir)) != NULL)
        {
            if(!strcmp(filename->d_name, ".") || !strcmp(filename->d_name, ".."))
                continue;
        
            sprintf(src_path, "%s/%s", argv, filename->d_name);
        
            lstat(src_path, &sstat);
        
            if(!S_ISDIR(sstat.st_mode))
            {
                pecker_mcla_analysis_pe_file(g_mcla, src_path, &report, 0);
                if(report >= PE_MARWARE_CPL)
                {
                    total_num++;
                    bad_num++;
                }
                else if(report == PE_MARWARE_OK)
                {
                    total_num++;
                    good_num++;
                }
            }
        }
        printf("total_num: %d, good_num: %d, bad_num: %d\n", total_num, good_num, bad_num);
        closedir(dir);
    }
        
}

