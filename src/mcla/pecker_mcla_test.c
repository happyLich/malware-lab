#include <base/pecker.h>
#include "pecker_mcla.h"
#include "pecker_mcla_img.h"
#include <getopt.h>

#define DEAD_CODE 0
#define MCLA_TEST_HELP  \
    "Usage: %s [OPTION...] [STRING...]\n\n" \
    "    -h, --help                      display this help and exit\n\n"\
    "    -r, --read-img                  test function of read image\n"\
    "    -w, --write-img                 test function of write image\n"\
    "    -g, --glcm                      test function of calc glcm value\n\n"

static char *progname;     /* used throughout */
static mcla_t *g_mcla = NULL;
static int opt;
static struct option longopts[] = {
    {"help", 0, NULL, 'h'},
    {"read-img", 1, NULL, 'r'},
    {"write-img", 1, NULL, 'w'},
    {"glcm", 1, NULL, 'g'},
    {0,0,0,0}
};

void mcla_test_help(void);
void glcm_function(char *argv);
void read_img_function(char *argv);
void write_img_function(char *argv);

int main(int argc, char **argv)
{
    int ret = 0;
    int helpinfo = 1;
    
    g_mcla = pecker_mcla_init();

    if ((progname = strrchr(argv[0], '/')) != NULL)
        progname++;
    else
        progname = argv[0];

    while((opt = getopt_long(argc, argv, "hg:r:w:", longopts, NULL)) != -1)
    {
        switch(opt)
        {
            case 'r':
                helpinfo = 0;
                read_img_function(optarg);
                break;
            case 'w':
                helpinfo = 0;
                write_img_function(optarg);
                break;
            case 'g':
                helpinfo = 0;
                glcm_function(optarg);
                break;
            case 'h':
                helpinfo++;
                break;
            case '?':
                helpinfo++;
                break;
            default:
                helpinfo++;
                break;
        }
    }
    
    if(helpinfo)
        mcla_test_help();
    
    pecker_mcla_free(g_mcla);
    
    return ret;
}

void mcla_test_help(void)
{
    (void)fprintf(stderr, MCLA_TEST_HELP, progname);
    exit(1);
}

void glcm_function(char *argv)
{
    FILE *fp = NULL;
    uint32_t len;
    uint8_t *buf;
    glcm_val_t glcm_val;
    struct stat  sstat;
    
    fp = fopen(argv, "r");
    if(NULL == fp)
    {
        printf("open  %s failed\n", argv);
        return;
    }
    
    stat(argv, &sstat);
    len = sstat.st_size;
    buf = (uint8_t *)malloc(len);
    if(len == fread(buf, 1, len, fp))
    {
        printf("make_glcm len:%d\n", len);
        calc_all_glcm(buf, len, 256, GLCM_ANGLE_HORIZATION, 1, &glcm_val);
        printf("_mean: %f\n", glcm_val._mean);
        printf("_variance: %f\n", glcm_val._variance);
        printf("_asm: %f\n", glcm_val._asm);
        printf("_contrast: %f\n", glcm_val._contrast);
        printf("_correlation: %f\n", glcm_val._correlation);
        printf("_dissimilarity: %f\n", glcm_val._dissimilarity);
        printf("_entropy: %f\n", glcm_val._entropy);
        printf("_homogeneity: %f\n", glcm_val._homogeneity);
    }
    free(buf);
    fclose(fp);
}

void read_img_function(char *argv)
{
    read_img(argv);
}

void write_img_function(char *argv)
{
    FILE *fp = NULL;
    uint32_t len;
    uint8_t *buf;
    struct stat sstat;
    char dst[1024];
    
    fp = fopen(argv, "r");
    if(NULL == fp)
    {
        printf("open  %s failed\n", argv);
        return;
    }
    
    stat(argv, &sstat);
    len = sstat.st_size;
    buf = (uint8_t *)malloc(len);
    if(len == fread(buf, 1, len, fp))
    {
        sprintf(dst, "%s.png", argv);
        if(0 == binary_to_img(buf, len, 512, 512, dst))
        {
            printf("%s is saved!!\n", dst);
        }
        else
        {
            printf("save %s failed!!\n", dst);
        }
    }
    
    free(buf);
    fclose(fp);
}

