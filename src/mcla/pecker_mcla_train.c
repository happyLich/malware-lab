#include <base/pecker.h>
#include <base/pecker_log.h>

#include "pecker_mcla_train.h"
#include "pecker_mcla_util.h"
#include "pecker_mcla_img.h"

//DOING
uint8_t **get_asm_opcode_seq(char *filename)
{
    int ret = PECKER_MCLA_OK;
    uint8_t buf[65535]= "";    
    uint8_t **seq = NULL;
    uint32_t seq_num = 0;
    FILE *fp;

    fp = fopen(filename, "r");
    if(NULL == fp)
        return NULL;
    
    if(fgets(buf, 65534, fp))
    {
        //TODO:
    }

    fclose(fp);
    return seq;
}

//DONE
uint8_t **get_n_gram_seq(uint8_t **seq, int n)
{    
    uint8_t **tmp_seq = seq;
    uint8_t **ngram_seq = NULL;
    uint8_t buf[1024];
    uint32_t seq_num = 0;
    int i;
    
    if(n <= 0)
        return NULL;

    ngram_seq = (uint8_t **)malloc(sizeof(uint8_t *));

    while(tmp_seq && *tmp_seq)
    {
        bzero(buf, 1024);
        for(i = 0; i < n; i++)
        {
            if(*(tmp_seq + i))
            {
                strcat(buf, *(tmp_seq + i));
                strcat(buf, ",");
            }
            else
            {
                goto exit;
            }
        }
        
        ngram_seq = (uint8_t **)realloc(ngram_seq, sizeof(uint8_t *) * (seq_num + 2));
        ngram_seq[seq_num] = strdup(buf);
        seq_num++;
        tmp_seq++;
    }

exit:
    ngram_seq[seq_num] = NULL;
    return ngram_seq;
}

void free_seq(uint8_t **seq)
{
    uint8_t **tmp_seq = seq;
    while(tmp_seq && *tmp_seq)
    {
        free(*tmp_seq);
        *tmp_seq = NULL;
        tmp_seq++;
    }
    PECKER_MCLA_FREE(tmp_seq);
}

static int ece_compare(const void *a ,const void *b)
{
    feat_node_t *node_a = (feat_node_t *)a;
    feat_node_t *node_b = (feat_node_t *)b;

    if(node_a->ece < node_b->ece)
        return 1;
    if(node_a->ece == node_b->ece)
        return 0;
    if(node_a->ece > node_b->ece)
        return -1;
}

//DONE
int train_feature(train_feat_para_t *para, char *dst, uint32_t num)
{
    int ret = PECKER_MCLA_OK;
    FILE *fp;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
    
    fp = fopen(dst, "w");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;

    feat_node_t *feat_list = para->feat_list;
    feat_node_t *feat_node;
    uint32_t feat_num = para->feat_num;
    uint32_t *c_count = para->c_count;
    uint32_t cn = para->cn;
    uint32_t sample_num = para->sample_num;

    double tmp_ece;
    double pwc = 0, pc = 0, pw = 0;
    uint32_t i, j;
    uint32_t cfc, cc, df;
    for(i = 0; i < feat_num; i++)
    {
        tmp_ece = 0;
        feat_node = feat_list + i;
        df = feat_node->df;
        if(df == 0)
            df++;
        pw = (double)df / sample_num;
        for(j = 0; j < cn; j++)
        {
            cfc = feat_node->c_count[j];
            if(cfc == 0)
                cfc++;
            cc = c_count[j];
            pwc = (double)cfc / cc;
            pc = (double)cc / sample_num;
            tmp_ece += ((pwc*pc/pw) * log(pwc/pw));
        }
        feat_node->ece = tmp_ece;
    }

    qsort(feat_list, feat_num, sizeof(feat_node_t), ece_compare);
    
    for(i = 0; i < feat_num && i < num; i++)
    {
        feat_node = feat_list + i;
        fprintf(fp, "%s\n", feat_node->feat);
    }
    
    fclose(fp);
    return ret;
}


//creat image feature train data
int init_img_train_data_para(img_train_data_para_t *para, uint32_t width, int dist, uint8_t angel)
{
    int ret = PECKER_MCLA_OK;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;

    para->img_list = NULL;
    para->img_num = 0;
    para->img_max = 0;
    para->width = width;
    para->dist = dist;
    para->angel = angel;

    return ret;
}

int add_img_train_data(img_train_data_para_t *para, char *src, int lable)
{
    int ret = PECKER_MCLA_OK;
    FILE *fp = NULL;
    uint32_t len;
    uint8_t *buf;
    struct stat sstat;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
    
    fp = fopen(src, "r");
    if(NULL == fp)
    {
        pecker_log(PECKER_LOG_ERR, "open  %s failed\n", src);
        return PECKER_MCLA_OPEN_FILE_FAIL;
    }
    
    stat(src, &sstat);
    len = sstat.st_size;
    buf = (uint8_t *)malloc(len);
    if(len == fread(buf, 1, len, fp))
    {
        if(para->img_num >= para->img_max)
        {
            para->img_list = (img_node_t *)realloc(para->img_list, 
                    (para->img_max + IMAGE_NODE_REALLOC_SIZE) * sizeof(img_node_t));
            para->img_max += IMAGE_NODE_REALLOC_SIZE;
        }
        para->img_list[para->img_num].lable = lable;
        calc_all_glcm(buf, len, para->width, para->angel, para->dist, &(para->img_list[para->img_num].glcm_v));
        pecker_log(PECKER_LOG_DEBUG, "_mean: %f\n", para->img_list[para->img_num].glcm_v._mean);
        pecker_log(PECKER_LOG_DEBUG, "_variance: %f\n", para->img_list[para->img_num].glcm_v._variance);
        pecker_log(PECKER_LOG_DEBUG, "_asm: %f\n", para->img_list[para->img_num].glcm_v._asm);
        pecker_log(PECKER_LOG_DEBUG, "_contrast: %f\n", para->img_list[para->img_num].glcm_v._contrast);
        pecker_log(PECKER_LOG_DEBUG, "_correlation: %f\n", para->img_list[para->img_num].glcm_v._correlation);
        pecker_log(PECKER_LOG_DEBUG, "_dissimilarity: %f\n", para->img_list[para->img_num].glcm_v._dissimilarity);
        pecker_log(PECKER_LOG_DEBUG, "_entropy: %f\n", para->img_list[para->img_num].glcm_v._entropy);
        pecker_log(PECKER_LOG_DEBUG, "_homogeneity: %f\n", para->img_list[para->img_num].glcm_v._homogeneity);
        pecker_log(PECKER_LOG_INFO, "add %s lable:%d len:%d sucess\n", src, lable, len);
        para->img_num++;
    }
    else
    {
        pecker_log(PECKER_LOG_ERR, "read  %s failed\n", src);
        fclose(fp);
        ret = PECKER_MCLA_READ_FILE_FAIL;
    }
    
    fclose(fp);
    return ret;
}

int creat_img_train_data(img_train_data_para_t *para, char *dst)
{
    int ret = PECKER_MCLA_OK;
    FILE *fp;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
    
    fp = fopen(dst, "w");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;

    uint32_t i;
    img_node_t *img_node;
    fprintf(fp, "lable,contrast,homogeneity,correlation,dissimilarity,asm,entropy,mean,variance\n");
    for(i = 0; i < para->img_num; i++)
    {
        img_node = para->img_list + i;
        fprintf(fp, "%d,", img_node->lable);
        fprintf(fp, "%f,", img_node->glcm_v._contrast);
        fprintf(fp, "%f,", img_node->glcm_v._homogeneity);
        fprintf(fp, "%f,", img_node->glcm_v._correlation);
        fprintf(fp, "%f,", img_node->glcm_v._dissimilarity);
        fprintf(fp, "%f,", img_node->glcm_v._asm);
        fprintf(fp, "%f,", img_node->glcm_v._entropy);
        fprintf(fp, "%f,", img_node->glcm_v._mean);
        fprintf(fp, "%f", img_node->glcm_v._variance);
        fprintf(fp, "\n");
    }

    fclose(fp);
    return ret;
}

int free_img_train_data_para(img_train_data_para_t *para)
{
    if(para)
    {
        PECKER_MCLA_FREE(para->img_list);
    }
    return PECKER_MCLA_OK;
}

