#include <base/pecker.h>
#include <base/pecker_log.h>

#include "pecker_mcla_train.h"
#include "pecker_mcla_util.h"
 
//DOING
uint8_t **get_asm_opcode_seq(char *filename)
{
    int ret = PECKER_MCLA_OK;
    uint8_t buf[65535]= "";    
    uint8_t **seq = NULL;
    uint32_t seq_num = 0;
    FILE *fp;

    fp = fopen(filename, "r");
    if(NULL == fp)
        return NULL;
    
    if(fgets(buf, 65534, fp))
    {
        //TODO:
    }

    fclose(fp);
    return seq;
}

//DONE
uint8_t **get_n_gram_seq(uint8_t **seq, int n)
{    
    uint8_t **tmp_seq = seq;
    uint8_t **ngram_seq = NULL;
    uint8_t buf[1024];
    uint32_t seq_num = 0;
    int i;
    
    if(n <= 0)
        return NULL;

    ngram_seq = (uint8_t **)malloc(sizeof(uint8_t *));

    while(tmp_seq && *tmp_seq)
    {
        bzero(buf, 1024);
        for(i = 0; i < n; i++)
        {
            if(*(tmp_seq + i))
            {
                strcat(buf, *(tmp_seq + i));
                strcat(buf, ",");
            }
            else
            {
                goto exit;
            }
        }
        
        ngram_seq = (uint8_t **)realloc(ngram_seq, sizeof(uint8_t *) * (seq_num + 2));
        ngram_seq[seq_num] = strdup(buf);
        seq_num++;
        tmp_seq++;
    }

exit:
    ngram_seq[seq_num] = NULL;
    return ngram_seq;
}

void free_seq(uint8_t **seq)
{
    uint8_t **tmp_seq = seq;
    while(tmp_seq && *tmp_seq)
    {
        free(*tmp_seq);
        *tmp_seq = NULL;
        tmp_seq++;
    }
    PECKER_MCLA_FREE(tmp_seq);
}

static int ece_compare(const void *a ,const void *b)
{
    feat_node_t *node_a = (feat_node_t *)a;
    feat_node_t *node_b = (feat_node_t *)b;

    if(node_a->ece < node_b->ece)
        return 1;
    if(node_a->ece == node_b->ece)
        return 0;
    if(node_a->ece > node_b->ece)
        return -1;
}

//DONE
int train_feature(train_feat_para_t *para, char *dst, uint32_t num)
{
    int ret = PECKER_MCLA_OK;
    FILE *fp;
    
    if(para == NULL)
        return PECKER_MCLA_NULL_POINTER;
    
    fp = fopen(dst, "w");
    if(NULL == fp)
        return PECKER_MCLA_OPEN_FILE_FAIL;

    feat_node_t *feat_list = para->feat_list;
    feat_node_t *feat_node;
    uint32_t feat_num = para->feat_num;
    uint32_t *c_count = para->c_count;
    uint32_t cn = para->cn;
    uint32_t sample_num = para->sample_num;

    double tmp_ece;
    double pwc = 0, pc = 0, pw = 0;
    uint32_t i, j;
    uint32_t cfc, cc, df;
    for(i = 0; i < feat_num; i++)
    {
        tmp_ece = 0;
        feat_node = feat_list + i;
        df = feat_node->df;
        if(df == 0)
            df++;
        pw = (double)df / sample_num;
        for(j = 0; j < cn; j++)
        {
            cfc = feat_node->c_count[j];
            if(cfc == 0)
                cfc++;
            cc = c_count[j];
            pwc = (double)cfc / cc;
            pc = (double)cc / sample_num;
            tmp_ece += ((pwc*pc/pw) * log(pwc/pw));
        }
        feat_node->ece = tmp_ece;
    }

    qsort(feat_list, feat_num, sizeof(feat_node_t), ece_compare);
    
    for(i = 0; i < feat_num && i < num; i++)
    {
        feat_node = feat_list + i;
        fprintf(fp, "%s\n", feat_node->feat);
    }
    
    fclose(fp);
    return ret;
}

